"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfObjectLoader = void 0;
const jsonld_context_parser_1 = require("jsonld-context-parser");
const rdf_string_1 = require("rdf-string");
const RdfListMaterializer_1 = require("./RdfListMaterializer");
const Resource_1 = require("./Resource");
/**
 * Take a stream or array of RDF quads and loads them as linked resources.
 */
class RdfObjectLoader {
    constructor(args) {
        this.resources = {};
        if (args) {
            Object.assign(this, args);
        }
        if (this.normalizeLists !== false) {
            this.normalizeLists = true;
        }
        this.context = new jsonld_context_parser_1.ContextParser().parse(this.context || {});
        this.context.then((contextResolved) => this.contextResolved = contextResolved);
    }
    /**
     * Get the resource object for the given term.
     * If it does not exist, one will be created.
     * @param {Term} term An RDF term.
     * @return {Resource} A resource.
     */
    getOrMakeResource(term) {
        const termString = rdf_string_1.termToString(term);
        let resource = this.resources[termString];
        if (!resource) {
            resource = new Resource_1.Resource({ term, context: this.contextResolved });
            this.resources[termString] = resource;
        }
        return resource;
    }
    /**
     * Import the given stream of RDF quads.
     * Resources will be created and linked for all passed terms.
     * @param {Stream} stream A stream of RDF quads.
     * @return {Promise<void>} A promise that resolves when the stream has ended.
     * @template Q The type of quad, defaults to RDF.Quad.
     */
    import(stream) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            yield this.context;
            const listMaterializer = new RdfListMaterializer_1.RdfListMaterializer();
            if (this.normalizeLists) {
                listMaterializer.import(stream);
            }
            stream.on('data', (quad) => {
                const subject = this.getOrMakeResource(quad.subject);
                const predicate = this.getOrMakeResource(quad.predicate);
                const object = this.getOrMakeResource(quad.object);
                subject.addProperty(predicate, object);
            });
            stream.on('error', reject);
            stream.on('end', () => {
                if (this.normalizeLists) {
                    for (const listRoot of listMaterializer.getRoots()) {
                        const listTerms = listMaterializer.getList(listRoot);
                        this.resources[rdf_string_1.termToString(listRoot)].list = listTerms.map((term) => this.resources[rdf_string_1.termToString(term)]);
                    }
                }
                resolve();
            });
        }));
    }
    /**
     * Import the given array of RDF quads.
     * Resources will be created and linked for all passed terms.
     * @param {Q[]} quads An array of RDF quads.
     * @return {Promise<void>} A promise that resolves when the array has been fully imported.
     * @template Q The type of quad, defaults to RDF.Quad.
     */
    importArray(quads) {
        return this.import(require('streamify-array')(quads));
    }
}
exports.RdfObjectLoader = RdfObjectLoader;
//# sourceMappingURL=RdfObjectLoader.js.map