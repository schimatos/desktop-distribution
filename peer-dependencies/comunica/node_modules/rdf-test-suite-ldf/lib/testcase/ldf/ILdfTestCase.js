"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ldfTestCaseFromResource = void 0;
const rdf_string_1 = require("rdf-string");
/**
 * Create a test case object from a resource.
 * @param {{[uri: string]: ITestCaseHandler<ITestCase<any>>}} testCaseHandlers Handlers for constructing test cases.
 * @param {string} cachePath The base directory to cache files in. If falsy, then no cache will be used.
 * @param {Resource} resource A resource.
 * @return {Promise<ITestCase<any>>} A promise resolving to a test case object.
 */
function ldfTestCaseFromResource(factory, testCaseHandlers, options, resource) {
    return __awaiter(this, void 0, void 0, function* () {
        const baseTestCase = {
            approval: resource.property.approval ? resource.property.approval.value : null,
            approvedBy: resource.property.approvedBy ? resource.property.approvedBy.value : null,
            comment: resource.property.comment ? resource.property.comment.value : null,
            name: resource.property.name ? resource.property.name.value : null,
            types: resource.properties.types.map((r) => rdf_string_1.termToString(r.term)),
            uri: resource.term.value,
        };
        if (!baseTestCase.types.length) {
            // Ignore undefined test cases, this is applicable in the official test cases,
            // like http://www.w3.org/2009/sparql/docs/tests/data-sparql11/http-rdf-update/manifest#put__empty_graph
            return null;
        }
        // Find the first handler that has all its required types in the given test case
        let handler;
        for (const testCaseHandlerKey in testCaseHandlers) {
            const testCaseHandlerTypes = testCaseHandlerKey.split(' ');
            const availableTypes = resource.properties.types.map((term) => term.value);
            let valid = true;
            for (const testCaseHandlerType of testCaseHandlerTypes) {
                if (availableTypes.indexOf(testCaseHandlerType) < 0) {
                    valid = false;
                    break;
                }
            }
            if (valid) {
                handler = testCaseHandlers[testCaseHandlerKey];
                break;
            }
        }
        if (!handler) {
            // tslint:disable-next-line:no-console
            console.error(new Error(`Could not find a test case handler for ${resource.value} with types ${baseTestCase.types}`).toString());
            return null;
        }
        try {
            return yield handler.resourceToLdfTestCase(resource, factory, baseTestCase, options);
        }
        catch (e) {
            // tslint:disable-next-line:no-console
            console.error(e.toString());
            return null;
        }
    });
}
exports.ldfTestCaseFromResource = ldfTestCaseFromResource;
//# sourceMappingURL=ILdfTestCase.js.map