"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LdfTestCaseEvaluation = exports.LdfTestCaseEvaluationHandler = void 0;
const fse = require("fs-extra");
const Path = require("path");
const rdf_parse_1 = require("rdf-parse");
const rdf_store_stream_1 = require("rdf-store-stream");
const rdf_test_suite_1 = require("rdf-test-suite");
const stringifyStream = require("stream-to-string");
const Logger_1 = require("../../factory/Logger");
const LdfUtil_1 = require("../../LdfUtil");
/**
 * Test case handler for
 * https://comunica.github.io/ontology-query-testing/ontology-query-testing.ttl#LdfQueryEvaluationTest.
 */
class LdfTestCaseEvaluationHandler {
    resourceToLdfTestCase(resource, factory, testCaseData, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!resource.property.action) {
                throw new Error(`Missing mf:action in ${resource}`);
            }
            if (!resource.property.result) {
                throw new Error(`Missing mf:result in ${resource}`);
            }
            if (!resource.property.dataSources || resource.property.dataSources.list.length <= 0) {
                throw new Error(`Missing et:dataSources in ${resource}`);
            }
            const action = resource.property.action;
            if (!action.property.query) {
                throw new Error(`Missing qt:query in mf:action of ${resource}`);
            }
            const queryResponse = yield rdf_test_suite_1.Util.fetchCached(resource.property.result.value, options);
            return new LdfTestCaseEvaluation(testCaseData, {
                baseIRI: rdf_test_suite_1.Util.normalizeBaseUrl(action.property.query.value),
                dataSources: yield Promise.all([].concat.apply([], resource.properties.dataSources.map((entrySources) => entrySources.list.map((entry) => {
                    return { value: entry.property.source.value, type: entry.property.sourceType.value };
                })))),
                mockFolder: action.property.mockFolder ? action.property.mockFolder.value : undefined,
                queryResult: yield rdf_test_suite_1.TestCaseQueryEvaluationHandler.parseQueryResult(rdf_test_suite_1.Util.identifyContentType(queryResponse.url, queryResponse.headers), queryResponse.url, queryResponse.body),
                queryString: yield stringifyStream((yield rdf_test_suite_1.Util.fetchCached(action.property.query.value, options)).body),
                resultSource: queryResponse,
            }, factory, options);
        });
    }
}
exports.LdfTestCaseEvaluationHandler = LdfTestCaseEvaluationHandler;
class LdfTestCaseEvaluation {
    constructor(testCaseData, props, factory, options) {
        this.type = "ldf";
        Object.assign(this, testCaseData);
        Object.assign(this, props);
        this.factory = factory;
        this.tmpFolder = (options && options.cachePath) ? options.cachePath : Path.join(process.cwd(), 'tmpfolder');
        this.options = options;
        this.createdFolder = false;
    }
    test(engine, injectArguments) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                // Set up mock-server, load all resources
                this.responseMocker = yield this.factory.getNewLdfResponseMocker();
                this.responseMocker.loadSources(this.dataSources);
                this.responseMocker.loadTest(this);
                yield this.responseMocker.setUpServer();
                Logger_1.logger.info(rdf_test_suite_1.Util.withColor(`Run test: ${this.uri}`, rdf_test_suite_1.Util.COLOR_GREEN));
                // Query and retrieve result
                this.mapSources(this.dataSources)
                    .then((sources) => __awaiter(this, void 0, void 0, function* () {
                    const timeStart = process.hrtime();
                    const result = yield engine.queryLdf(sources, this.responseMocker.proxyAddress, this.queryString, {
                        baseIRI: this.baseIRI,
                    });
                    const timeEnd = process.hrtime(timeStart);
                    const duration = (timeEnd[0] * 1000) + (timeEnd[1] / 1000000);
                    // Wait a bit, as the engine may have background processes that will still need the server
                    if (this.factory.options.serverTerminationDelay > 0) {
                        yield new Promise((subResolve) => setTimeout(subResolve, this.factory.options.serverTerminationDelay));
                    }
                    // Tear down the mock-server for all sources
                    yield this.responseMocker.tearDownServer();
                    if (this.createdFolder) {
                        fse.emptyDirSync(this.tmpFolder);
                    }
                    if (!(yield this.queryResult.equals(result))) {
                        reject(new Error(`${rdf_test_suite_1.Util.withColor('Invalid query evaluation', rdf_test_suite_1.Util.COLOR_RED)}

        ${rdf_test_suite_1.Util.withColor('Query:', rdf_test_suite_1.Util.COLOR_YELLOW)} ${this.queryString}

        ${rdf_test_suite_1.Util.withColor('Data:', rdf_test_suite_1.Util.COLOR_YELLOW)} ${JSON.stringify(this.dataSources) || 'none'}

        ${rdf_test_suite_1.Util.withColor('Result Source:', rdf_test_suite_1.Util.COLOR_YELLOW)} ${this.resultSource.url}

        ${rdf_test_suite_1.Util.withColor('Expected:', rdf_test_suite_1.Util.COLOR_YELLOW)} \n ${this.queryResult}

        ${rdf_test_suite_1.Util.withColor('Got:', rdf_test_suite_1.Util.COLOR_YELLOW)} \n ${result.toString()}
        `));
                    }
                    resolve({ duration });
                }))
                    .catch((reason) => __awaiter(this, void 0, void 0, function* () {
                    yield this.responseMocker.tearDownServer();
                    reject(new Error(reason));
                }));
            }));
        });
    }
    /**
     * Map the manifest-sourceTypes to the sourcetypes the engine uses (based on comunica-engines).
     * @param sources The sources from the manifest file
     */
    mapSources(sources) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const rtrn = [];
            for (const source of sources) {
                const is = source;
                switch (source.type.split('#')[1]) {
                    case 'TPF':
                        is.type = '';
                        break;
                    case 'File':
                        is.type = 'file';
                        break;
                    case 'SPARQL':
                        is.type = 'sparql';
                        break;
                    case 'HDT':
                        fse.ensureDirSync(this.tmpFolder);
                        const hdtFile = source.value.split('/').slice(-1)[0];
                        if (!fse.existsSync(hdtFile)) {
                            yield LdfUtil_1.LdfUtil.fetchFile(this.tmpFolder, source, this.options);
                        }
                        if (!this.options || !this.options.cachePath) {
                            this.createdFolder = true;
                        }
                        is.type = 'hdtFile';
                        is.value = Path.join(this.tmpFolder, hdtFile);
                        break;
                    case 'RDFJS':
                        fse.ensureDirSync(this.tmpFolder);
                        const rdfjsFile = source.value.split('/').slice(-1)[0];
                        if (!fse.existsSync(rdfjsFile)) {
                            yield LdfUtil_1.LdfUtil.fetchFile(this.tmpFolder, source, this.options);
                        }
                        const stream = fse.createReadStream(Path.join(this.tmpFolder, rdfjsFile));
                        const quadStream = rdf_parse_1.default.parse(stream, { contentType: 'text/turtle' });
                        if (!this.options || !this.options.cachePath) {
                            this.createdFolder = true;
                        }
                        is.value = yield rdf_store_stream_1.storeStream(quadStream);
                        is.type = 'rdfjsSource';
                        break;
                    default:
                        reject(new Error(`The sourcetype: ${source.type} is not known.`));
                }
                rtrn.push(source);
            }
            resolve(rtrn);
        }));
    }
}
exports.LdfTestCaseEvaluation = LdfTestCaseEvaluation;
//# sourceMappingURL=LdfTestCaseEvaluationHandler.js.map