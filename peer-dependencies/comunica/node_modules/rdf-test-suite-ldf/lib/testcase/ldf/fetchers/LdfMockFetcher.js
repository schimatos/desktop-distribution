"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LdfMockFetcher = void 0;
const crypto = require("crypto");
const rdf_test_suite_1 = require("rdf-test-suite");
/**
 * Class that fetches the mocked testfiles.
 */
class LdfMockFetcher {
    constructor(test) {
        this.test = test;
    }
    /**
     * Parse the mocked testfiles.
     * @param requestedURI The URI of the request the engine requests
     * @param object The LdfTestCaseEvaluation we're testing
     * @param {IFetchOptions} options Options for fetching.
     * @returns IMockedResponse representing the mocked testfiles
     */
    parseMockedResponse(requestedURI, options) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let body = '';
            const mockedUrl = this.getMockedFileURI(this.test.mockFolder, requestedURI);
            let incoming;
            try {
                incoming = (yield rdf_test_suite_1.Util.fetchCached(mockedUrl, options)).body;
            }
            catch (e) {
                return reject(Error(`Failed to fetch ${mockedUrl}, for original resource ${requestedURI}.`));
            }
            incoming.on('data', (chunk) => {
                body += chunk;
            });
            incoming.on('end', () => {
                // parse response and return
                try {
                    const headerResponse = this.pickHeaderLines(body);
                    const headers = this.parseMockedFileHeaders(mockedUrl, headerResponse.header);
                    const response = {
                        body: headerResponse.body,
                        contentType: headers['Content-type'],
                        iri: headers['Hashed IRI'],
                        query: headers.Query,
                    };
                    resolve(response);
                }
                catch (err) {
                    reject(err);
                }
            });
        }));
    }
    /**
     * Get the URI of the mocked testfile, by hashing the requestedURI and using the
     * URI of the folder containing the testfiles.
     * @param mockFolderURI The URI of the folder containing the mocked testfiles
     * @param requestedURI The URI of the request the engine requests
     */
    getMockedFileURI(mockFolderURI, requestedURI) {
        if (mockFolderURI.endsWith('/')) {
            // test the mockfolderURI on trailing slashes
            mockFolderURI = mockFolderURI.slice(0, mockFolderURI.length - 1);
        }
        return mockFolderURI + '/' + crypto.createHash('sha1').update(decodeURIComponent(requestedURI)).digest('hex');
    }
    /**
     * Parse the headers of a mocked testfile (cfr. https://github.com/comunica/ontology-query-testing#README).
     * @param headers The header lines of the mocked testfile.
     * @returns a map with the header values.
     */
    parseMockedFileHeaders(uri, headers) {
        const result = {};
        const parts = [];
        let part = '';
        for (const line of headers.split('\n')) {
            if (line.startsWith('#')) {
                if (part.length > 0) {
                    parts.push(part);
                }
                part = '';
            }
            part += line;
        }
        parts.push(part);
        part = '';
        for (part of parts) {
            if (part.indexOf(':') < 0) {
                throw new Error(`Mocked testfile does not have valid header line: ${part} - ${uri}`);
            }
            part = part.substring(2); // Remove '# '
            const key = part.substring(0, part.indexOf(':')).trim(); // Parse key
            const value = part.substring(part.indexOf(':') + 1).trim(); // Parse value
            result[key] = value; // Put in dictionary
        }
        return result;
    }
    pickHeaderLines(body) {
        const headerLines = [];
        let hashcount = 0;
        while (hashcount < 3) {
            const line = body.split('\n')[0];
            body = body.split('\n').splice(1).join('\n');
            if (line.startsWith('#')) {
                hashcount += 1;
            }
            headerLines.push(line);
        }
        return {
            body,
            header: headerLines.join('\n'),
        };
    }
}
exports.LdfMockFetcher = LdfMockFetcher;
//# sourceMappingURL=LdfMockFetcher.js.map