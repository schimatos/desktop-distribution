"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.manifestFromSpecificationResource = exports.manifestFromResource = void 0;
const ITestCase_1 = require("./testcase/ITestCase");
const Util_1 = require("./Util");
/**
 * Create a manifest object from a resource.
 * @param {{[uri: string]: ITestCaseHandler<ITestCase<any>>}} testCaseHandlers Handlers for constructing test cases.
 * @param {IFetchOptions} options The fetch options.
 * @param {Resource} resource A resource.
 * @return {Promise<IManifest>} A promise resolving to a manifest object.
 */
function manifestFromResource(testCaseHandlers, options, resource) {
    return __awaiter(this, void 0, void 0, function* () {
        return {
            comment: resource.property.comment ? resource.property.comment.value : null,
            label: resource.property.label ? resource.property.label.value : null,
            specifications: resource.property.specifications ? yield Util_1.Util.promiseValues(Object.assign.apply({}, yield Promise.all(resource.property.specifications.list
                .map((specificationResource) => ({ [specificationResource.term.value]: manifestFromSpecificationResource(testCaseHandlers, options, specificationResource) }))))) : null,
            subManifests: yield Promise.all([].concat.apply([], resource.properties.include.map((includeList) => includeList.list
                .map(manifestFromResource.bind(null, testCaseHandlers, options))))),
            testEntries: (yield Promise.all([].concat.apply([], resource.properties.entries.map((entryList) => (entryList.list || [entryList])
                .map(ITestCase_1.testCaseFromResource.bind(null, testCaseHandlers, options))))))
                .filter((v) => v),
            uri: resource.value,
        };
    });
}
exports.manifestFromResource = manifestFromResource;
/**
 * Create a manifest object from a specification resource.
 * @param {{[uri: string]: ITestCaseHandler<ITestCase<any>>}} testCaseHandlers Handlers for constructing test cases.
 * @param {IFetchOptions} options The fetch options.
 * @param {Resource} resource A resource.
 * @return {Promise<IManifest>} A promise resolving to a manifest object.
 */
function manifestFromSpecificationResource(testCaseHandlers, options, resource) {
    return __awaiter(this, void 0, void 0, function* () {
        if (resource.property.conformanceRequirements) {
            const subManifests = yield Promise.all(resource.property.conformanceRequirements.list
                .map(manifestFromResource.bind(null, testCaseHandlers, options)));
            return {
                comment: resource.property.comment ? resource.property.comment.value : null,
                label: resource.property.label ? resource.property.label.value : null,
                subManifests,
                uri: resource.value,
            };
        }
        else {
            return {
                comment: resource.property.comment ? resource.property.comment.value : null,
                label: resource.property.label ? resource.property.label.value : null,
                uri: resource.value,
            };
        }
    });
}
exports.manifestFromSpecificationResource = manifestFromSpecificationResource;
//# sourceMappingURL=IManifest.js.map