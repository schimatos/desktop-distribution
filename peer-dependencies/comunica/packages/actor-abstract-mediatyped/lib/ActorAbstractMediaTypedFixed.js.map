{"version":3,"file":"ActorAbstractMediaTypedFixed.js","sourceRoot":"","sources":["ActorAbstractMediaTypedFixed.ts"],"names":[],"mappings":";;;AAEA,uEAAoE;AAEpE,MAAsB,4BAAyC,SAAQ,iDAAmC;IAiBxG,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,MAAM,KAAK,GAAW,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9F,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC,CAAE,GAAG,EAAE,KAAK,CAAE,EAAE,KAAK,EAAE,EAAE;gBAChE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK,GAAG,KAAK,CAAC;YACvC,CAAC,CAAC,CAAC;SACJ;QACD,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACjD,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAC/D,CAAC;IAEM,KAAK,CAAC,UAAU,CAAC,MAAU,EAAE,SAAiB,EAAE,OAAsB;QAC3E,IAAI,CAAC,CAAC,SAAS,IAAI,IAAI,CAAC,UAAU,CAAC,EAAE;YACnC,MAAM,IAAI,KAAK,CAAC,4BAA4B,SAAS,EAAE,CAAC,CAAC;SAC1D;QACD,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;IAWM,KAAK,CAAC,aAAa,CAAC,OAAsB;QAC/C,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,OAAsB;QAC/C,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,oBAAoB,CAAC,OAAsB;QACtD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,mBAAmB,CAAC,OAAsB;QACrD,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;CACF;AA5DD,oEA4DC","sourcesContent":["import type { ActionContext } from '@comunica/core';\nimport type { IActorArgsMediaTyped } from './ActorAbstractMediaTyped';\nimport { ActorAbstractMediaTyped } from './ActorAbstractMediaTyped';\n\nexport abstract class ActorAbstractMediaTypedFixed<HI, HT, HO> extends ActorAbstractMediaTyped<HI, HT, HO> {\n  /**\n   * A hash of media types, with media type name as key, and its priority as value.\n   * Priorities are numbers between [0, 1].\n   */\n  public readonly mediaTypes: Record<string, number>;\n  /**\n   * A hash of media types, with media type name as key, and its format IRI as value.\n   */\n  public readonly mediaTypeFormats: Record<string, string>;\n  /**\n   * A multiplier for media type priorities.\n   * This can be used for keeping the original media types in place,\n   * but scaling all of their scores with a certain value.\n   */\n  public readonly priorityScale: number;\n\n  public constructor(args: IActorArgsMediaTypedFixed<HI, HT, HO>) {\n    super(args);\n    const scale: number = this.priorityScale || this.priorityScale === 0 ? this.priorityScale : 1;\n    if (this.mediaTypes) {\n      Object.entries(this.mediaTypes).forEach(([ key, value ], index) => {\n        this.mediaTypes[key] = scale * value;\n      });\n    }\n    this.mediaTypes = Object.freeze(this.mediaTypes);\n    this.mediaTypeFormats = Object.freeze(this.mediaTypeFormats);\n  }\n\n  public async testHandle(action: HI, mediaType: string, context: ActionContext): Promise<HT> {\n    if (!(mediaType in this.mediaTypes)) {\n      throw new Error(`Unrecognized media type: ${mediaType}`);\n    }\n    return await this.testHandleChecked(action, context);\n  }\n\n  /**\n   * Check to see if this actor can handle the given action.\n   * The media type has already been checked before this is called.\n   *\n   * @param {ActionContext} context An optional context.\n   * @param {HI} action The action to test.\n   */\n  public abstract testHandleChecked(action: HI, context: ActionContext): Promise<HT>;\n\n  public async testMediaType(context: ActionContext): Promise<boolean> {\n    return true;\n  }\n\n  public async getMediaTypes(context: ActionContext): Promise<Record<string, number>> {\n    return this.mediaTypes;\n  }\n\n  public async testMediaTypeFormats(context: ActionContext): Promise<boolean> {\n    return true;\n  }\n\n  public async getMediaTypeFormats(context: ActionContext): Promise<Record<string, string>> {\n    return this.mediaTypeFormats;\n  }\n}\n\nexport interface IActorArgsMediaTypedFixed<HI, HT, HO> extends IActorArgsMediaTyped<HI, HT, HO> {\n  mediaTypes: Record<string, number>;\n  priorityScale?: number;\n}\n"]}