{"version":3,"file":"ActorAbstractPath.js","sourceRoot":"","sources":["ActorAbstractPath.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorQueryOperationTypedMediatedArgs,\n  IActorQueryOperationOutputBindings } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated,\n  Bindings,\n} from '@comunica/bus-query-operation';\nimport type { IActorTest } from '@comunica/core';\nimport { ActionContext } from '@comunica/core';\nimport type { AsyncIterator } from 'asynciterator';\nimport { BufferedIterator, MultiTransformIterator,\n  TransformIterator, EmptyIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { Term, Variable } from 'rdf-js';\nimport { termToString } from 'rdf-string';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\nconst DF = new DataFactory();\n\n/**\n * An abstract actor that handles Path operations.\n *\n * Provides multiple helper functions used by the Path operation actors.\n */\nexport abstract class ActorAbstractPath extends ActorQueryOperationTypedMediated<Algebra.Path> {\n  protected static readonly FACTORY: Factory = new Factory();\n\n  protected readonly predicateType: string;\n\n  public static isPathArbitraryLengthDistinctKey = 'isPathArbitraryLengthDistinct';\n\n  protected constructor(args: IActorQueryOperationTypedMediatedArgs, predicateType: string) {\n    super(args, 'path');\n    this.predicateType = predicateType;\n  }\n\n  public async testOperation(pattern: Algebra.Path, context: ActionContext): Promise<IActorTest> {\n    if (pattern.predicate.type !== this.predicateType) {\n      throw new Error(`This Actor only supports ${this.predicateType} Path operations.`);\n    }\n\n    return true;\n  }\n\n  // Generates a variable that does not yet occur in the path\n  public generateVariable(path?: Algebra.Path, name?: string): Variable {\n    if (!name) {\n      return this.generateVariable(path, 'b');\n    }\n\n    // Path predicates can't contain variables\n    if (path && (path.subject.value === name || path.object.value === name)) {\n      return this.generateVariable(path, `${name}b`);\n    }\n\n    return DF.variable(name);\n  }\n\n  // Such connectivity matching does not introduce duplicates (it does not incorporate any count of the number\n  // of ways the connection can be made) even if the repeated path itself would otherwise result in duplicates.\n  // https://www.w3.org/TR/sparql11-query/#propertypaths\n  public async isPathArbitraryLengthDistinct(context: ActionContext, path: Algebra.Path):\n  Promise<{context: ActionContext; operation: IActorQueryOperationOutputBindings | undefined}> {\n    if (!context || !context.get(ActorAbstractPath.isPathArbitraryLengthDistinctKey)) {\n      context = context ?\n        context.set(ActorAbstractPath.isPathArbitraryLengthDistinctKey, true) :\n        ActionContext({ [ActorAbstractPath.isPathArbitraryLengthDistinctKey]: true });\n      return { context,\n        operation: ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n          operation: ActorAbstractPath.FACTORY.createDistinct(path),\n          context,\n        })) };\n    }\n\n    context = context.set(ActorAbstractPath.isPathArbitraryLengthDistinctKey, false);\n    return { context, operation: undefined };\n  }\n\n  private async predicateStarGraphVariable(subject: Term, object: Variable, predicate: Algebra.PropertyPathSymbol,\n    graph: Term, context: ActionContext): Promise<AsyncIterator<Bindings>> {\n    // Construct path to obtain all graphs where subject exists\n    const predVar = this.generateVariable(ActorAbstractPath.FACTORY.createPath(subject, predicate, object, graph));\n    const findGraphs = ActorAbstractPath.FACTORY.createUnion(\n      ActorAbstractPath.FACTORY.createPattern(subject, predVar, object, graph),\n      ActorAbstractPath.FACTORY.createPattern(object, predVar, subject, graph),\n    );\n    const results = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ context, operation: findGraphs }),\n    );\n\n    const objectString = termToString(object);\n    const passedGraphs: Set<string> = new Set();\n\n    return new MultiTransformIterator(\n      results.bindingsStream,\n      {\n        multiTransform: (bindings: Bindings) => {\n          // Extract the graph and start a predicate* search starting from subject in each graph\n          const graphValue = bindings.get(termToString(graph));\n          if (passedGraphs.has(termToString(graphValue))) {\n            return new EmptyIterator();\n          }\n          passedGraphs.add(termToString(graphValue));\n          return new TransformIterator<Bindings>(\n            async() => {\n              const it = new BufferedIterator<Term>();\n              await this.getObjectsPredicateStar(subject, predicate, graphValue, context, {}, it, { count: 0 });\n              return it.transform<Bindings>({\n                transform(item, next, push) {\n                  push(Bindings({ [objectString]: item, [termToString(graph)]: graphValue }));\n                  next();\n                },\n              });\n            }, { maxBufferSize: 128 },\n          );\n        },\n        autoStart: false,\n      },\n    );\n  }\n\n  /**\n     * Returns an iterator with Bindings of the query subject predicate* ?o\n     * If graph is a variable, it will also be in those bindings\n     * @param {Term} subject Term of where we start the predicate* search.\n     * @param {Variable} object Variable of the zeroOrMore-query.\n     * @param {Term} objectVal\n     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n     * @param {Term} graph The graph in which we search for the pattern. (Possibly a variable)\n     * @param {ActionContext} context\n     * @return {Promise<AsyncIterator<Bindings>} Iterator to where all bindings of query should have been pushed.\n     */\n  public async getObjectsPredicateStarEval(subject: Term, object: Variable, predicate: Algebra.PropertyPathSymbol,\n    graph: Term, context: ActionContext): Promise<AsyncIterator<Bindings>> {\n    if (graph.termType === 'Variable') {\n      return this.predicateStarGraphVariable(subject, object, predicate, graph, context);\n    }\n\n    const it = new BufferedIterator<Term>();\n    await this.getObjectsPredicateStar(subject, predicate, graph, context, {}, it, { count: 0 });\n\n    return it.transform<Bindings>({\n      transform(item, next, push) {\n        push(Bindings({ [termToString(object)]: item }));\n        next();\n      },\n    });\n  }\n\n  /**\n     * Pushes all terms to iterator `it` that are a solution of object predicate* ?o.\n     * @param {Term} object Term of where we start the predicate* search.\n     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n     * @param {Term} graph The graph in which we search for the pattern.\n     * @param {ActionContext} context\n     * @param {{[id: string]: Term}} termHashes Remembers the objects we've already searched for.\n     * @param {BufferedIterator<Term>} it Iterator to push terms to.\n     * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n     * @return {Promise<void>} All solutions of query should have been pushed to it by then.\n     */\n  public async getObjectsPredicateStar(object: Term, predicate: Algebra.PropertyPathSymbol, graph: Term,\n    context: ActionContext, termHashes: Record<string, Term>, it: BufferedIterator<Term>, counter: any): Promise<void> {\n    const termString = termToString(object);\n    if (termHashes[termString]) {\n      return;\n    }\n\n    (<any> it)._push(object);\n    termHashes[termString] = object;\n    counter.count++;\n\n    const thisVariable = this.generateVariable();\n    const vString = termToString(thisVariable);\n    const path = ActorAbstractPath.FACTORY.createPath(object, predicate, thisVariable, graph);\n    const results = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ operation: path, context }),\n    );\n    results.bindingsStream.on('data', async bindings => {\n      const result = bindings.get(vString);\n      await this.getObjectsPredicateStar(result, predicate, graph, context, termHashes, it, counter);\n    });\n    results.bindingsStream.on('end', () => {\n      if (--counter.count === 0) {\n        it.close();\n      }\n    });\n  }\n\n  /**\n     * Pushes all terms to iterator `it` that are a solution of ?s predicate* ?o.\n     * @param {string} subjectString String representation of subjectVariable\n     * @param {string} objectString String representation of objectVariable\n     * @param {Term} subjectVal Term of where we start the predicate* search.\n     * @param {Term} objectVal Found solution for an object, start for the new step.\n     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n     * @param {Term} graph The graph in which we search for the pattern.\n     * @param {ActionContext} context\n     * @param {{[id: string]: Promise<Term[]>}} termHashesGlobal\n     * Remembers solutions for when objectVal is already been calculated, can be reused when same objectVal occurs\n     * @param {{[id: string]: Term}} termHashesCurrentSubject\n     * Remembers the pairs we've already searched for, can stop searching if so.\n     * @param {BufferedIterator<Bindings>} it Iterator to push terms to.\n     * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n     * @return {Promise<void>} All solutions of query should have been pushed to it by then.\n     */\n  // Let the iterator `it` emit all bindings of size 2, with subjectStringVariable as value subjectVal\n  // and objectStringVariable as value all nodes reachable through predicate* beginning at objectVal\n  public async getSubjectAndObjectBindingsPredicateStar(subjectString: string, objectString: string, subjectVal: Term,\n    objectVal: Term, predicate: Algebra.PropertyPathSymbol, graph: Term, context: ActionContext,\n    termHashesGlobal: Record<string, Promise<Term[]>>, termHashesCurrentSubject: Record<string, boolean>,\n    it: BufferedIterator<Bindings>, counter: any): Promise<void> {\n    const termString = termToString(objectVal) + termToString(graph);\n\n    // If this combination of subject and object already done, return nothing\n    if (termHashesCurrentSubject[termString]) {\n      return;\n    }\n\n    counter.count++;\n    termHashesCurrentSubject[termString] = true;\n    (<any> it)._push(Bindings({ [subjectString]: subjectVal, [objectString]: objectVal }));\n\n    // If every reachable node from object has already been calculated, use these for current subject too\n    if (termString in termHashesGlobal) {\n      const objects = await termHashesGlobal[termString];\n      for (const object of objects) {\n        await this.getSubjectAndObjectBindingsPredicateStar(\n          subjectString,\n          objectString,\n          subjectVal,\n          object,\n          predicate,\n          graph,\n          context,\n          termHashesGlobal,\n          termHashesCurrentSubject,\n          it,\n          counter,\n        );\n      }\n      if (--counter.count === 0) {\n        it.close();\n      }\n\n      return;\n    }\n\n    // Construct promise to calculate all reachable nodes from this object\n    const promise = new Promise<Term[]>(async(resolve, reject) => {\n      const objectsArray: Term[] = [];\n\n      // Construct path that leads us one step through predicate\n      const thisVariable = this.generateVariable();\n      const vString = termToString(thisVariable);\n      const path = ActorAbstractPath.FACTORY.createPath(objectVal, predicate, thisVariable, graph);\n      const results = ActorQueryOperation.getSafeBindings(\n        await this.mediatorQueryOperation.mediate({ operation: path, context }),\n      );\n\n      // Recursive call on all neighbours\n      results.bindingsStream.on('data', async bindings => {\n        const result = bindings.get(vString);\n        objectsArray.push(result);\n        await this.getSubjectAndObjectBindingsPredicateStar(\n          subjectString,\n          objectString,\n          subjectVal,\n          result,\n          predicate,\n          graph,\n          context,\n          termHashesGlobal,\n          termHashesCurrentSubject,\n          it,\n          counter,\n        );\n      });\n      results.bindingsStream.on('error', reject);\n      results.bindingsStream.on('end', () => {\n        if (--counter.count === 0) {\n          it.close();\n        }\n        resolve(objectsArray);\n      });\n    });\n\n    // Set it in the termHashesGlobal when this object occurs again they can wait for this promise\n    termHashesGlobal[termString] = promise;\n  }\n}\n"]}