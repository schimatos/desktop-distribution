{"version":3,"file":"ActorHttpMemento.js","sourceRoot":"","sources":["ActorHttpMemento.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA,iDAA+C;AAE/C,gCAA8B;AAC9B,6DAA+C;AAE/C;;GAEG;AACH,MAAa,gBAAiB,SAAQ,oBAAS;IAI7C,YAAmB,IAA2B;QAC5C,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAAmB;;QACnC,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,4BAAoB,CAAC;YAC1D,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,4BAAoB,CAAC,YAAY,IAAI,CAAC,EAAE;YAC/D,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAC;SAC/E;QACD,IAAI,MAAM,CAAC,IAAI,IAAI,IAAI,OAAO,OAAC,MAAM,CAAC,IAAI,CAAC,OAAO,mCAAI,EAAE,CAAC,CAAC,GAAG,CAAC,iBAAiB,CAAC,EAAE;YAChF,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;SAC5D;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAmB;;QAClC,uEAAuE;QACvE,MAAM,IAAI,GAAgB,MAAM,CAAC,IAAI,CAAC,CAAC,mBAAM,MAAM,CAAC,IAAI,EAAG,CAAC,CAAC,EAAE,CAAC;QAChE,MAAM,OAAO,GAAY,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,OAAC,IAAI,CAAC,OAAO,mCAAI,EAAE,CAAC,CAAC;QAExE,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,4BAAoB,CAAC,EAAE;YAC9D,OAAO,CAAC,MAAM,CAAC,iBAAiB,EAAE,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,4BAAoB,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC;SAC3F;QAED,MAAM,UAAU,GAAgB,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,MAAM,CAAC,KAAK,EAAE,IAAI,EAAE,CAAC;QAEvF,wEAAwE;QACxE,MAAM,MAAM,GAAqB,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QAE7E,uEAAuE;QACvE,IAAI,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,IAAI,MAAM,CAAC,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,kBAAkB,CAAC,EAAE;YAC/F,mDAAmD;YACnD,aAAa;YACb,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,SAAS,CAAU,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;YAC3F,IAAI,KAAK,IAAI,KAAK,CAAC,QAAQ,EAAE;gBAC3B,IAAI,MAAM,CAAC,IAAI,EAAE;oBACf,MAAM,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC;iBAC5B;gBACD,oEAAoE;gBACpE,MAAM,UAAU,GAAgB,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE,KAAK,EAAE,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC;gBAC7F,OAAO,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;aAC9C;SACF;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAlDD,4CAkDC;AAQD;;GAEG;AACU,QAAA,oBAAoB,GAAG,uCAAuC,CAAC","sourcesContent":["import type { IActionHttp, IActorHttpOutput } from '@comunica/bus-http';\nimport { ActorHttp } from '@comunica/bus-http';\nimport type { IActorArgs, IActorTest, Mediator } from '@comunica/core';\nimport 'cross-fetch/polyfill';\nimport * as parseLink from 'parse-link-header';\n\n/**\n * A comunica Memento Http Actor.\n */\nexport class ActorHttpMemento extends ActorHttp {\n  public readonly mediatorHttp: Mediator<ActorHttp,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n\n  public constructor(args: IActorHttpMementoArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionHttp): Promise<IActorTest> {\n    if (!(action.context && action.context.has(KEY_CONTEXT_DATETIME) &&\n          action.context.get(KEY_CONTEXT_DATETIME) instanceof Date)) {\n      throw new Error('This actor only handles request with a set valid datetime.');\n    }\n    if (action.init && new Headers(action.init.headers ?? {}).has('accept-datetime')) {\n      throw new Error('The request already has a set datetime.');\n    }\n    return true;\n  }\n\n  public async run(action: IActionHttp): Promise<IActorHttpOutput> {\n    // Duplicate the ActionHttp to append a datetime header to the request.\n    const init: RequestInit = action.init ? { ...action.init } : {};\n    const headers: Headers = init.headers = new Headers(init.headers ?? {});\n\n    if (action.context && action.context.has(KEY_CONTEXT_DATETIME)) {\n      headers.append('accept-datetime', action.context.get(KEY_CONTEXT_DATETIME).toUTCString());\n    }\n\n    const httpAction: IActionHttp = { context: action.context, input: action.input, init };\n\n    // Execute the request and follow the timegate in the response (if any).\n    const result: IActorHttpOutput = await this.mediatorHttp.mediate(httpAction);\n\n    // Did we ask for a time-negotiated response, but haven't received one?\n    if (headers.has('accept-datetime') && result.headers && !result.headers.has('memento-datetime')) {\n      // The links might have a timegate that can help us\n      // @ts-ignore\n      const links = result.headers.has('link') && parseLink(<string> result.headers.get('link'));\n      if (links && links.timegate) {\n        if (result.body) {\n          await result.body.cancel();\n        }\n        // Respond with a time-negotiated response from the timegate instead\n        const followLink: IActionHttp = { context: action.context, input: links.timegate.url, init };\n        return this.mediatorHttp.mediate(followLink);\n      }\n    }\n\n    return result;\n  }\n}\n\nexport interface IActorHttpMementoArgs\n  extends IActorArgs<IActionHttp, IActorTest, IActorHttpOutput> {\n  mediatorHttp: Mediator<ActorHttp,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n}\n\n/**\n * @type {string} Context entry for the desired datetime.\n */\nexport const KEY_CONTEXT_DATETIME = '@comunica/actor-http-memento:datetime';\n"]}