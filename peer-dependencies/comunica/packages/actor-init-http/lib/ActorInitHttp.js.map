{"version":3,"file":"ActorInitHttp.js","sourceRoot":"","sources":["ActorInitHttp.ts"],"names":[],"mappings":";;;AAAA,mCAAqC;AAErC,iDAA+C;AAE/C,iDAA+C;AAG/C;;;;GAIG;AACH,MAAa,aAAc,SAAQ,oBAAS;IAQ1C,YAAmB,IAAwB;QACzC,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAAmB;QACnC,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAmB;;QAClC,MAAM,IAAI,GAAgB;YACxB,OAAO,EAAE,MAAM,CAAC,OAAO;YACvB,IAAI,EAAE,EAAE;YACR,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,OAAC,IAAI,CAAC,GAAG,mCAAI,EAAE;SAChE,CAAC;QACF,IAAI,IAAI,CAAC,MAAM,EAAE;YACA,IAAI,CAAC,IAAK,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;SAChD;QACD,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,MAAM,OAAO,GAAY,IAAI,OAAO,EAAE,CAAC;YACvC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO,EAAE;gBAChC,MAAM,CAAC,GAAW,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBACrC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;aACrE;YACc,IAAI,CAAC,IAAK,CAAC,OAAO,GAAG,OAAO,CAAC;SAC7C;QAED,MAAM,YAAY,GAAqB,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC7E,MAAM,MAAM,GAAqB,EAAE,CAAC;QACpC,6DAA6D;QAC7D,qGAAqG;QACrG,MAAM,cAAc,GAA0B,oBAAS,CAAC,cAAc,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QAC1F,IAAI,YAAY,CAAC,MAAM,KAAK,GAAG,EAAE;YAC/B,MAAM,CAAC,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,oBAAW,EAAE,CAAC,CAAC;SACxD;aAAM;YACL,MAAM,CAAC,MAAM,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,oBAAW,EAAE,CAAC,CAAC;SACxD;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA9CD,sCA8CC","sourcesContent":["import { PassThrough } from 'stream';\nimport type { IActionHttp, IActorHttpOutput } from '@comunica/bus-http';\nimport { ActorHttp } from '@comunica/bus-http';\nimport type { IActionInit, IActorOutputInit } from '@comunica/bus-init';\nimport { ActorInit } from '@comunica/bus-init';\nimport type { Actor, IActorArgs, IActorTest, Mediator } from '@comunica/core';\n\n/**\n * A http actor that listens on the 'init' bus.\n *\n * It will call `this.mediatorHttp.mediate`.\n */\nexport class ActorInitHttp extends ActorInit implements IActorInitHttpArgs {\n  public readonly mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n\n  public readonly url?: string;\n  public readonly method?: string;\n  public readonly headers?: string[];\n\n  public constructor(args: IActorInitHttpArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionInit): Promise<IActorTest> {\n    return true;\n  }\n\n  public async run(action: IActionInit): Promise<IActorOutputInit> {\n    const http: IActionHttp = {\n      context: action.context,\n      init: {},\n      input: action.argv.length > 0 ? action.argv[0] : this.url ?? '',\n    };\n    if (this.method) {\n      (<RequestInit> http.init).method = this.method;\n    }\n    if (this.headers) {\n      const headers: Headers = new Headers();\n      for (const value of this.headers) {\n        const i: number = value.indexOf(':');\n        headers.append(value.slice(0, i).toLowerCase(), value.slice(i + 2));\n      }\n      (<RequestInit> http.init).headers = headers;\n    }\n\n    const httpResponse: IActorHttpOutput = await this.mediatorHttp.mediate(http);\n    const output: IActorOutputInit = {};\n    // Wrap WhatWG readable stream into a Node.js readable stream\n    // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n    const responseStream: NodeJS.ReadableStream = ActorHttp.toNodeReadable(httpResponse.body);\n    if (httpResponse.status === 200) {\n      output.stdout = responseStream.pipe(new PassThrough());\n    } else {\n      output.stderr = responseStream.pipe(new PassThrough());\n    }\n    return output;\n  }\n}\n\nexport interface IActorInitHttpArgs extends IActorArgs<IActionInit, IActorTest, IActorOutputInit> {\n  mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n  url?: string;\n  method?: string;\n  headers?: string[];\n}\n"]}