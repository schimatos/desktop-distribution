{"version":3,"file":"ActorQueryOperationBgpEmpty.js","sourceRoot":"","sources":["ActorQueryOperationBgpEmpty.ts"],"names":[],"mappings":";;;AAGA,uEAGuC;AAEvC,iDAAkD;AAClD,2CAA0C;AAC1C,yCAAgD;AAGhD;;GAEG;AACH,MAAa,2BAA4B,SAAQ,8CAAqC;IACpF,YAAmB,IAA+E;QAChG,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACrB,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,YAAY,CAAC,QAA2B;QACpD,OAAO,qBAAS,CAAC,QAAQ;aACtB,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,oBAAQ,CAAC,OAAO,CAAC;aAC9B,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC,CAAC;aAC/C,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,CAAC;aAC1C,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,yBAAY,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,OAAoB,EAAE,OAAsB;QACrE,IAAI,OAAO,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,IAAI,kCAAkC,CAAC,CAAC;SACvE;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,OAAoB,EAAE,OAAsB;QACpE,OAAO;YACL,cAAc,EAAE,IAAI,iCAAiB,CAAC,8BAAQ,CAAC,EAAE,CAAC,CAAC;YACnD,QAAQ,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC;YAClD,IAAI,EAAE,UAAU;YAChB,SAAS,EAAE,2BAA2B,CAAC,YAAY,CAAC,OAAO,CAAC,QAAQ,CAAC;YACrE,gBAAgB,EAAE,KAAK;SACxB,CAAC;IACJ,CAAC;CACF;AAnCD,kEAmCC","sourcesContent":["import type { IActionQueryOperation,\n  IActorQueryOperationOutput,\n  IActorQueryOperationOutputBindings } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperationTyped,\n  Bindings,\n} from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorArgs, IActorTest } from '@comunica/core';\nimport { SingletonIterator } from 'asynciterator';\nimport { termToString } from 'rdf-string';\nimport { getTerms, uniqTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Query Operation Actor for empty BGPs.\n */\nexport class ActorQueryOperationBgpEmpty extends ActorQueryOperationTyped<Algebra.Bgp> {\n  public constructor(args: IActorArgs<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>) {\n    super(args, 'bgp');\n  }\n\n  /**\n   * Get all variables in the given patterns.\n   * No duplicates are returned.\n   * @param {Algebra.Pattern} patterns Quad patterns.\n   * @return {string[]} The variables in this pattern, with '?' prefix.\n   */\n  public static getVariables(patterns: Algebra.Pattern[]): string[] {\n    return uniqTerms(patterns\n      .map(pattern => getTerms(pattern)\n        .filter(term => term.termType === 'Variable'))\n      .reduce((acc, val) => acc.concat(val), []))\n      .map(x => termToString(x));\n  }\n\n  public async testOperation(pattern: Algebra.Bgp, context: ActionContext): Promise<IActorTest> {\n    if (pattern.patterns.length > 0) {\n      throw new Error(`Actor ${this.name} can only operate on empty BGPs.`);\n    }\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Bgp, context: ActionContext): Promise<IActorQueryOperationOutputBindings> {\n    return {\n      bindingsStream: new SingletonIterator(Bindings({})),\n      metadata: () => Promise.resolve({ totalItems: 1 }),\n      type: 'bindings',\n      variables: ActorQueryOperationBgpEmpty.getVariables(pattern.patterns),\n      canContainUndefs: false,\n    };\n  }\n}\n"]}