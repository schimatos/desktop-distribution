{"version":3,"file":"ActorQueryOperationBgpLeftDeepSmallest.js","sourceRoot":"","sources":["ActorQueryOperationBgpLeftDeepSmallest.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Bindings,\n  BindingsStream,\n\n  IActorQueryOperationOutputBindings,\n  IActorQueryOperationTypedMediatedArgs,\n  IPatternBindings } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated,\n  KEY_CONTEXT_BGP_CURRENTMETADATA,\n  KEY_CONTEXT_BGP_PARENTMETADATA,\n  KEY_CONTEXT_BGP_PATTERNBINDINGS,\n} from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport { ArrayIterator, MultiTransformIterator, TransformIterator } from 'asynciterator';\nimport type * as RDF from 'rdf-js';\nimport { termToString } from 'rdf-string';\nimport type { QuadTermName } from 'rdf-terms';\nimport { mapTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Query Operation Actor that resolves BGPs in a left-deep manner\n * based on the pattern with the smallest item count.\n */\nexport class ActorQueryOperationBgpLeftDeepSmallest extends ActorQueryOperationTypedMediated<Algebra.Bgp> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'bgp');\n  }\n\n  /**\n   * Create a new bindings stream\n   * that takes every binding of the base stream,\n   * materializes the remaining patterns with it,\n   * and emits all bindings from this new set of patterns.\n   * @param {BindingsStream} baseStream The base stream.\n   * @param {Algebra.Pattern[]} patterns The patterns to materialize with each binding of the base stream.\n   * @param {{ pattern: Algebra.Pattern, bindings: IPatternBindings }[]) => Promise<IActorQueryOperationOutput>}\n   *    patternBinder A callback\n   * to retrieve the bindings stream of an array of patterns.\n   * @return {BindingsStream}\n   */\n  public static createLeftDeepStream(baseStream: BindingsStream, patterns: Algebra.Pattern[],\n    patternBinder:\n    (bindPatterns: { pattern: Algebra.Pattern; bindings: IPatternBindings }[]) =>\n    Promise<BindingsStream>): BindingsStream {\n    return new MultiTransformIterator(baseStream, {\n      autoStart: false,\n      multiTransform(bindings: Bindings) {\n        const bindingsMerger = (subBindings: Bindings): Bindings => subBindings.merge(bindings);\n        return new TransformIterator(\n          async() => (await patternBinder(ActorQueryOperationBgpLeftDeepSmallest.materializePatterns(patterns,\n            bindings))).transform({ map: bindingsMerger }), { maxBufferSize: 128 },\n        );\n      },\n    });\n  }\n\n  /**\n   * Get the combined list of variables of the given pattern outputs.\n   * @param {IActorQueryOperationOutput[]} patternOutputs An array of query operation outputs\n   * @return {string[]} The array of variable names.\n   */\n  public static getCombinedVariables(patternOutputs: IActorQueryOperationOutputBindings[]): string[] {\n    const withDuplicates = (<string[]> []).concat.apply([],\n      patternOutputs.map(patternOutput => patternOutput.variables));\n    // @ts-ignore\n    return [ ...new Set(withDuplicates) ];\n  }\n\n  /**\n   * Find the pattern index with the smallest number of elements.\n   * @param {{[p: string]: any}[]} metadatas An array of optional metadata objects for the patterns.\n   * @return {number} The index of the pattern with the smallest number of elements.\n   */\n  public static getSmallestPatternId(metadatas: (Record<string, any> | undefined)[]): number {\n    let smallestId = -1;\n    let smallestCount = Infinity;\n    for (const [ i, meta ] of metadatas.entries()) {\n      const count: number = ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(meta);\n      if (count <= smallestCount) {\n        smallestCount = count;\n        smallestId = i;\n      }\n    }\n    return smallestId;\n  }\n\n  /**\n   * Estimate an upper bound for the total number of items from the given metadata.\n   * @param {{[p: string]: any}} smallestPattern The optional metadata for the pattern\n   *                                             with the smallest number of elements.\n   * @param {{[p: string]: any}[]} otherPatterns The array of optional metadata for the other patterns.\n   * @return {number} The estimated number of total items.\n   */\n  public static estimateCombinedTotalItems(smallestPattern: Record<string, any> | undefined,\n    otherPatterns: (Record<string, any> | undefined)[]): number {\n    const smallestCount: number = ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(smallestPattern);\n    return otherPatterns\n      .map(otherPattern => smallestCount * ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(\n        otherPattern,\n      ))\n      .reduce((sum, element) => sum + element, 0);\n  }\n\n  /**\n   * Get the estimated number of items from the given metadata.\n   * @param {{[p: string]: any}} metadata An optional metadata object.\n   * @return {number} The estimated number of items, or `Infinity` if metadata is falsy.\n   */\n  public static getTotalItems(metadata?: Record<string, any>): number {\n    const { totalItems } = metadata ?? {};\n    return totalItems || totalItems === 0 ? totalItems : Infinity;\n  }\n\n  /**\n   * Materialize all patterns in the given pattern array with the given bindings.\n   * @param {Pattern[]} patterns SPARQL algebra patterns.\n   * @param {Bindings} bindings A bindings object.\n   * @return { pattern: Algebra.Pattern, bindings: IPatternBindings }[] An array of patterns with their bindings.\n   */\n  public static materializePatterns(patterns: Algebra.Pattern[], bindings: Bindings):\n  { pattern: Algebra.Pattern; bindings: IPatternBindings }[] {\n    return patterns.map(pattern => ActorQueryOperationBgpLeftDeepSmallest.materializePattern(\n      pattern, bindings,\n    ));\n  }\n\n  /**\n   * Materialize a pattern with the given bindings.\n   * @param {Pattern} pattern A SPARQL algebra pattern.\n   * @param {Bindings} bindings A bindings object.\n   * @return { pattern: Algebra.Pattern, bindings: IPatternBindings } A new materialized pattern.\n   */\n  public static materializePattern(pattern: Algebra.Pattern, bindings: Bindings):\n  { pattern: Algebra.Pattern; bindings: IPatternBindings } {\n    const bindingsOut: IPatternBindings = {};\n    const patternOut = <Algebra.Pattern> Object.assign(mapTerms(pattern,\n      (term: RDF.Term, termPosition: QuadTermName) => {\n        const materializedTerm = ActorQueryOperationBgpLeftDeepSmallest.materializeTerm(term, bindings);\n        if (term !== materializedTerm) {\n          bindingsOut[termPosition] = <RDF.Variable> term;\n        }\n        return materializedTerm;\n      }),\n    { type: 'pattern', context: pattern.context });\n    return { pattern: patternOut, bindings: bindingsOut };\n  }\n\n  /**\n   * Materialize a term with the given binding.\n   *\n   * If the given term is a variable (or blank node)\n   * and that variable exist in the given bindings object,\n   * the value of that binding is returned.\n   * In all other cases, the term itself is returned.\n   *\n   * @param {RDF.Term} term A term.\n   * @param {Bindings} bindings A bindings object.\n   * @return {RDF.Term} The materialized term.\n   */\n  public static materializeTerm(term: RDF.Term, bindings: Bindings): RDF.Term {\n    if (term.termType === 'Variable') {\n      const value: RDF.Term = bindings.get(termToString(term));\n      if (value) {\n        return value;\n      }\n    }\n    return term;\n  }\n\n  /**\n   * Check if at least one of the given outputs has an empty output, i.e., when the estimated count is zero.\n   * @param {IActorQueryOperationOutputBindings[]} patternOutputs Pattern outputs.\n   * @return {Promise<boolean>} A promise for indicating whether or not at least one of the outputs is empty.\n   */\n  public static async hasOneEmptyPatternOutput(patternOutputs: IActorQueryOperationOutputBindings[]): Promise<boolean> {\n    for (const patternOutput of patternOutputs) {\n      if (patternOutput.metadata) {\n        const metadata: Record<string, any> = await patternOutput.metadata();\n        if (!ActorQueryOperationBgpLeftDeepSmallest.getTotalItems(metadata)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public async testOperation(pattern: Algebra.Bgp, context: ActionContext): Promise<IActorTest> {\n    if (pattern.patterns.length < 2) {\n      throw new Error(`Actor ${this.name} can only operate on BGPs with at least two patterns.`);\n    }\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Bgp, context: ActionContext): Promise<IActorQueryOperationOutputBindings> {\n    // Get the total number of items for all patterns by resolving the quad patterns\n    const patternOutputs: IActorQueryOperationOutputBindings[] = (await Promise.all(pattern.patterns\n      .map((subPattern: Algebra.Pattern) => this.mediatorQueryOperation.mediate(\n        { operation: subPattern, context },\n      ))))\n      .map(ActorQueryOperation.getSafeBindings);\n\n    // If a triple pattern has no matches, the entire graph pattern has no matches.\n    if (await ActorQueryOperationBgpLeftDeepSmallest.hasOneEmptyPatternOutput(patternOutputs)) {\n      return {\n        bindingsStream: new ArrayIterator([], { autoStart: false }),\n        metadata: () => Promise.resolve({ totalItems: 0 }),\n        type: 'bindings',\n        variables: ActorQueryOperationBgpLeftDeepSmallest.getCombinedVariables(patternOutputs),\n        canContainUndefs: false,\n      };\n    }\n\n    // Find the pattern with the smallest number of elements\n    const metadatas: Record<string, any>[] = await Promise.all(patternOutputs.map(\n      async patternOutput => patternOutput.metadata ? await patternOutput.metadata() : {},\n    ));\n    const smallestId: number = ActorQueryOperationBgpLeftDeepSmallest.getSmallestPatternId(metadatas);\n\n    this.logDebug(context,\n      'Smallest pattern: ',\n      () => ({ pattern: pattern.patterns[smallestId], metadata: metadatas[smallestId] }));\n\n    // Close the non-smallest streams\n    for (const [ i, element ] of patternOutputs.entries()) {\n      if (i !== smallestId) {\n        element.bindingsStream.close();\n      }\n    }\n\n    // Take the pattern with the smallest number of items\n    const smallestPattern: IActorQueryOperationOutputBindings = patternOutputs.slice(smallestId)[0];\n    const remainingPatterns: Algebra.Pattern[] = pattern.patterns.concat([]);\n    remainingPatterns.splice(smallestId, 1);\n    const remainingMetadatas: Record<string, any>[] = metadatas.concat([]);\n    remainingMetadatas.splice(smallestId, 1);\n\n    // Check if the output type is correct\n    ActorQueryOperation.validateQueryOutput(smallestPattern, 'bindings');\n\n    // Materialize the remaining patterns for each binding in the stream.\n    const subContext = context && context\n      .set(KEY_CONTEXT_BGP_CURRENTMETADATA, metadatas[smallestId])\n      .set(KEY_CONTEXT_BGP_PARENTMETADATA, remainingMetadatas);\n    const bindingsStream: BindingsStream = ActorQueryOperationBgpLeftDeepSmallest.createLeftDeepStream(\n      smallestPattern.bindingsStream,\n      remainingPatterns,\n      async(patterns: { pattern: Algebra.Pattern; bindings: IPatternBindings }[]) => {\n        // Send the materialized patterns to the mediator for recursive BGP evaluation.\n        const operation: Algebra.Bgp = { type: 'bgp', patterns: patterns.map(pat => pat.pattern) };\n        const bindings = patterns.map(pat => pat.bindings);\n        return ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate(\n          { operation, context: subContext.set(KEY_CONTEXT_BGP_PATTERNBINDINGS, bindings) },\n        )).bindingsStream;\n      },\n    );\n\n    // Prepare variables and metadata\n    const variables: string[] = ActorQueryOperationBgpLeftDeepSmallest.getCombinedVariables(patternOutputs);\n    const metadata = (): Promise<Record<string, any>> => Promise.resolve({\n      totalItems: ActorQueryOperationBgpLeftDeepSmallest.estimateCombinedTotalItems(metadatas[smallestId],\n        metadatas.slice(smallestId)),\n    });\n\n    return { type: 'bindings', bindingsStream, variables, metadata, canContainUndefs: false };\n  }\n}\n"]}