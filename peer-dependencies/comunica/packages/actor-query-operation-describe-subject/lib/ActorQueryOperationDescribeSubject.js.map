{"version":3,"file":"ActorQueryOperationDescribeSubject.js","sourceRoot":"","sources":["ActorQueryOperationDescribeSubject.ts"],"names":[],"mappings":";;;AAAA,uFAAiF;AAGjF,uEAEuC;AAEvC,iDAA8C;AAC9C,uDAA+C;AAG/C,MAAM,EAAE,GAAG,IAAI,8BAAW,EAAgB,CAAC;AAE3C;;GAEG;AACH,MAAa,kCAAmC,SAAQ,sDAAkD;IACxG,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IAC1B,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,OAAyB,EAAE,OAAsB;QAC1E,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,OAAyB,EAAE,OAAsB;QAEzE,+DAA+D;QAC/D,MAAM,UAAU,GAAwB,OAAO,CAAC,KAAK;aAClD,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC;aAC5C,GAAG,CAAC,CAAC,IAAc,EAAE,EAAE;YACtB,kGAAkG;YAClG,MAAM,QAAQ,GAAmB;gBAC/B,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;aACnE,CAAC;YACF,4CAA4C;YAC5C,QAAQ,CAAC,OAAO,CAAC,CAAC,eAAoB,EAAE,EAAE,CAAC,eAAe,CAAC,IAAI,GAAG,SAAS,CAAC,CAAC;YAC7E,MAAM,iBAAiB,GAAsB,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAsB,QAAQ,EAAE,CAAC;YAErG,2BAA2B;YAC3B,OAA2B;gBACzB,KAAK,EAAE,iBAAiB;gBACxB,QAAQ,EAAsB,QAAQ;gBACtC,IAAI,EAAE,WAAW;aAClB,CAAC;QACJ,CAAC,CAAC,CAAC;QAEL,yCAAyC;QACzC,gGAAgG;QAChG,IAAI,UAAU,CAAC,MAAM,KAAK,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE;YAC9C,IAAI,gBAAgB,GAAsB,EAAE,CAAC;YAC7C,OAAO,CAAC,KAAK;iBACV,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC;iBAC5C,OAAO,CAAC,CAAC,IAAc,EAAE,CAAS,EAAE,EAAE;gBACrC,qEAAqE;gBACrE,MAAM,QAAQ,GAAmB;oBAC/B,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;iBAC3E,CAAC;gBACF,4CAA4C;gBAC5C,QAAQ,CAAC,OAAO,CAAC,CAAC,eAAoB,EAAE,EAAE,CAAC,eAAe,CAAC,IAAI,GAAG,SAAS,CAAC,CAAC;gBAC7E,gBAAgB,GAAG,gBAAgB,CAAC,MAAM,CAAqB,QAAQ,CAAC,CAAC;YAC3E,CAAC,CAAC,CAAC;YAEL,2CAA2C;YAC3C,kGAAkG;YAClG,UAAU,CAAC,IAAI,CAAC;gBACd,KAAK,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,gBAAgB,EAAE,EAAC;gBAC/F,QAAQ,EAAE,gBAAgB;gBAC1B,IAAI,EAAE,WAAW;aAClB,CAAC,CAAC;SACJ;QAED,iCAAiC;QACjC,MAAM,OAAO,GAAsC,CAAC,MAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAClF,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC,CACzE,CAAC,CAAC;aACA,GAAG,CAAC,yCAAmB,CAAC,YAAY,CAAC,CAAC;QAEzC,qCAAqC;QACrC,MAAM,UAAU,GAAG,IAAI,6BAAa,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;QAErG,yBAAyB;QACzB,MAAM,QAAQ,GAAuC,GAAG,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO;aAC3E,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,iCAAW,CAAC,CAAC,CAAC,CAAC,CAAC;aACzB,IAAI,CAAC,sDAAwB,CAAC,aAAa,CAAC,CAAC;QAEhD,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC;IACjD,CAAC;CACF;AAxED,gFAwEC","sourcesContent":["import { ActorQueryOperationUnion } from '@comunica/actor-query-operation-union';\nimport type { IActorQueryOperationOutputQuads,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation, ActorQueryOperationTypedMediated, getMetadata,\n} from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport { UnionIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport type * as RDF from 'rdf-js';\nimport type { Algebra } from 'sparqlalgebrajs';\nconst DF = new DataFactory<RDF.BaseQuad>();\n\n/**\n * A comunica Describe Subject Query Operation Actor.\n */\nexport class ActorQueryOperationDescribeSubject extends ActorQueryOperationTypedMediated<Algebra.Describe> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'describe');\n  }\n\n  public async testOperation(pattern: Algebra.Describe, context: ActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Describe, context: ActionContext):\n  Promise<IActorQueryOperationOutputQuads> {\n    // Create separate construct queries for all non-variable terms\n    const operations: Algebra.Construct[] = pattern.terms\n      .filter(term => term.termType !== 'Variable')\n      .map((term: RDF.Term) => {\n        // Transform each term to a separate construct operation with S ?p ?o patterns (BGP) for all terms\n        const patterns: RDF.BaseQuad[] = [\n          DF.quad(term, DF.variable('__predicate'), DF.variable('__object')),\n        ];\n        // eslint-disable-next-line no-return-assign\n        patterns.forEach((templatePattern: any) => templatePattern.type = 'pattern');\n        const templateOperation: Algebra.Operation = { type: 'bgp', patterns: <Algebra.Pattern[]> patterns };\n\n        // Create a construct query\n        return <Algebra.Construct> {\n          input: templateOperation,\n          template: <Algebra.Pattern[]> patterns,\n          type: 'construct',\n        };\n      });\n\n    // If we have variables in the term list,\n    // create one separate construct operation to determine these variables using the input pattern.\n    if (operations.length !== pattern.terms.length) {\n      let variablePatterns: Algebra.Pattern[] = [];\n      pattern.terms\n        .filter(term => term.termType === 'Variable')\n        .forEach((term: RDF.Term, i: number) => {\n          // Transform each term to an S ?p ?o pattern in a non-conflicting way\n          const patterns: RDF.BaseQuad[] = [\n            DF.quad(term, DF.variable(`__predicate${i}`), DF.variable(`__object${i}`)),\n          ];\n          // eslint-disable-next-line no-return-assign\n          patterns.forEach((templatePattern: any) => templatePattern.type = 'pattern');\n          variablePatterns = variablePatterns.concat(<Algebra.Pattern[]> patterns);\n        });\n\n      // Add a single construct for the variables\n      // This requires a join between the input pattern and our variable patterns that form a simple BGP\n      operations.push({\n        input: { type: 'join', left: pattern.input, right: { type: 'bgp', patterns: variablePatterns }},\n        template: variablePatterns,\n        type: 'construct',\n      });\n    }\n\n    // Evaluate the construct queries\n    const outputs: IActorQueryOperationOutputQuads[] = (await Promise.all(operations.map(\n      operation => this.mediatorQueryOperation.mediate({ operation, context }),\n    )))\n      .map(ActorQueryOperation.getSafeQuads);\n\n    // Take the union of all quad streams\n    const quadStream = new UnionIterator(outputs.map(output => output.quadStream), { autoStart: false });\n\n    // Take union of metadata\n    const metadata: () => Promise<Record<string, any>> = () => Promise.all(outputs\n      .map(x => getMetadata(x)))\n      .then(ActorQueryOperationUnion.unionMetadata);\n\n    return { type: 'quads', quadStream, metadata };\n  }\n}\n"]}