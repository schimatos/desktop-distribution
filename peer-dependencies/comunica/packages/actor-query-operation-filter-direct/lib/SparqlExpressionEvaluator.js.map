{"version":3,"file":"SparqlExpressionEvaluator.js","sourceRoot":"","sources":["SparqlExpressionEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable id-length */\nimport type { Bindings } from '@comunica/bus-query-operation';\nimport type * as RDF from 'rdf-js';\nimport { stringToTerm, termToString } from 'rdf-string';\nimport { Algebra } from 'sparqlalgebrajs';\n\n/**\n * Creates an evaluator function that executes the given Sxpression on the given Bindings.\n * This implementation is copied from the original LDF Client implementation.\n * THIS IMPLEMENTATION IS NOT FULLY SPEC COMPATIBLE!!!\n * But covers most of the standard cases.\n * @param {Expression} expr\n * @returns {(bindings: Bindings) => Term}\n */\nexport function createEvaluator(expr: Algebra.Expression): (bindings: Bindings) => (RDF.Term | undefined) {\n  const func = handleExpression(expr);\n  // Internally the expression evaluator uses primitives, so these have to be converted back\n  return (bindings: Bindings) => {\n    const str = func(bindings);\n    if (!str) {\n      return;\n    }\n    return stringToTerm(str);\n  };\n}\n\nfunction handleExpression(expr: Algebra.Expression): (bindings: Bindings) => (string | undefined) {\n  if (expr.expressionType === Algebra.expressionTypes.TERM) {\n    return handleTermExpression(<Algebra.TermExpression>expr);\n  }\n\n  if (expr.expressionType === Algebra.expressionTypes.NAMED) {\n    return handleNamedExpression(<Algebra.NamedExpression>expr);\n  }\n\n  if (expr.expressionType === Algebra.expressionTypes.OPERATOR) {\n    return handleOperatorExpression(<Algebra.OperatorExpression>expr);\n  }\n\n  throw new Error(`Unsupported Expression type: ${expr.expressionType}`);\n}\n\nfunction handleTermExpression(expr: Algebra.TermExpression): (bindings: Bindings) => (string | undefined) {\n  if (expr.term.termType === 'Variable') {\n    return bindings => {\n      const str = termToString(expr.term);\n      return bindings.has(str) ? termToString(bindings.get(str)) : undefined;\n    };\n  }\n  const str = termToString(expr.term);\n  return () => str;\n}\n\nfunction handleNamedExpression(expr: Algebra.NamedExpression): (bindings: Bindings) => string {\n  return handleFunction(expr.name.value, expr.args);\n}\n\nfunction handleOperatorExpression(expr: Algebra.OperatorExpression): (bindings: Bindings) => string {\n  return handleFunction(expr.operator, expr.args);\n}\n\nfunction handleFunction(operatorName: string, args: Algebra.Expression[]): (bindings: Bindings) => string {\n  const op = operators[operatorName];\n  if (!op) {\n    throw new Error(`Unsupported operator ${operatorName}`);\n  }\n\n  // Special case: some operators accept expressions instead of evaluated expressions\n  if (op.acceptsExpressions) {\n    return ((operator: any, unparsedArgs) => (bindings: Bindings) => operator.apply(bindings, unparsedArgs))(op, args);\n  }\n\n  const funcArgs = args.map(handleExpression);\n\n  return ((operator: any,\n    argumentExpressions: ((bindings: Bindings) => (string | undefined))[]) => (bindings: Bindings): string => {\n    // Evaluate the arguments\n    const resolvedArgs: (number | boolean | string | undefined)[] = new Array(argumentExpressions.length);\n    const origArgs: (string | undefined)[] = new Array(argumentExpressions.length);\n    for (const [ i, element ] of argumentExpressions.entries()) {\n      const arg = resolvedArgs[i] = origArgs[i] = element(bindings);\n      // Convert the arguments if necessary\n      switch (operator.type) {\n        case 'numeric':\n          resolvedArgs[i] = arg ? Number.parseFloat(literalValue(arg)) : undefined;\n          break;\n        case 'boolean':\n          resolvedArgs[i] = arg !== XSD_FALSE &&\n            (!isLiteral(arg) || literalValue(arg) !== '0');\n          break;\n      }\n    }\n    // Call the operator on the evaluated arguments\n    // eslint-disable-next-line prefer-spread\n    const result = operator.apply(null, resolvedArgs);\n    // Convert result if necessary\n    switch (operator.resultType) {\n      case 'numeric':\n        // eslint-disable-next-line no-case-declarations\n        let type = origArgs[0] ? getLiteralType(origArgs[0]) : undefined;\n        if (!type || type === XSD_STRING) {\n          type = XSD_INTEGER;\n        }\n        return `\"${result}\"^^${type}`;\n      case 'boolean':\n        return result ? XSD_TRUE : XSD_FALSE;\n      default:\n        return result;\n    }\n  })(op, funcArgs);\n}\n\nfunction isLiteral(entity: any): entity is string {\n  return typeof entity === 'string' && entity.startsWith('\"');\n}\n\nfunction literalValue(literal: string): string {\n  const match = /^\"([^]*)\"/u.exec(literal);\n  return (match && match[1]) || '';\n}\n\nfunction getLiteralType(literal: string): string {\n  const match = /^\"[^]*\"(?:\\^\\^([^\"]+)|(@)[^\"@]+)?$/u.exec(literal);\n  return (match && match[1]) ?? (match && match[2] ?\n    'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' :\n    'http://www.w3.org/2001/XMLSchema#string');\n}\n\nfunction getLiteralLanguage(literal: string): string {\n  const match = /^\"[^]*\"(?:@([^\"@]+)|\\^\\^[^\"]+)?$/u.exec(literal);\n  return match && match[1] ? match[1].toLowerCase() : '';\n}\n\nconst XSD = 'http://www.w3.org/2001/XMLSchema#';\nconst XSD_INTEGER = `${XSD}integer`;\nconst XSD_DOUBLE = `${XSD}double`;\nconst XSD_BOOLEAN = `${XSD}boolean`;\nconst XSD_STRING = `${XSD}string`;\nconst XSD_TRUE = `\"true\"^^${XSD_BOOLEAN}`;\nconst XSD_FALSE = `\"false\"^^${XSD_BOOLEAN}`;\n\n// Operators for each of the operator types\nconst operators: any = {\n  '+'(a: number, b: number): number {\n    return a + b;\n  },\n  '-'(a: number, b: number): number {\n    return a - b;\n  },\n  '*'(a: number, b: number): number {\n    return a * b;\n  },\n  '/'(a: number, b: number): number {\n    return a / b;\n  },\n  '='(a: any, b: any): boolean {\n    return a === b;\n  },\n  '!='(a: any, b: any): boolean {\n    return a !== b;\n  },\n  '<'(a: number, b: number): boolean {\n    return a < b;\n  },\n  '<='(a: number, b: number): boolean {\n    return a <= b;\n  },\n  '>'(a: number, b: number): boolean {\n    return a > b;\n  },\n  '>='(a: number, b: number): boolean {\n    return a >= b;\n  },\n  '!'(a: boolean): boolean {\n    return !a;\n  },\n  '&&'(a: boolean, b: boolean): boolean {\n    return a && b;\n  },\n  '||'(a: boolean, b: boolean): boolean {\n    return a || b;\n  },\n  'lang'(a: any): string | undefined {\n    return isLiteral(a) ? `\"${getLiteralLanguage(a).toLowerCase()}\"` : undefined;\n  },\n  'langmatches'(langTag: string, langRange: string): boolean {\n    // Implements https://tools.ietf.org/html/rfc4647#section-3.3.1\n    if (!langTag || !langRange) {\n      return false;\n    }\n    langTag = langTag.toLowerCase();\n    langRange = langRange.toLowerCase();\n    // eslint-disable-next-line no-return-assign\n    return langTag === langRange ||\n      ((langRange = literalValue(langRange)) === '*' && Boolean(langTag)) ||\n      // eslint-disable-next-line unicorn/prefer-string-slice\n      langTag.substr(1, langRange.length + 1) === `${langRange}-`;\n  },\n  'contains'(str: string, substring: string) {\n    substring = literalValue(substring);\n    str = literalValue(str);\n    return str.includes(substring);\n  },\n  'regex'(subject: string, pattern: string): boolean {\n    if (isLiteral(subject)) {\n      subject = literalValue(subject);\n    }\n    // eslint-disable-next-line require-unicode-regexp\n    return new RegExp(literalValue(pattern)).test(subject);\n  },\n  'str'(a: any): string {\n    return isLiteral(a) ? a : `\"${a}\"`;\n  },\n  'http://www.w3.org/2001/XMLSchema#integer'(a: number): string {\n    return `\"${Math.floor(a)}\"^^http://www.w3.org/2001/XMLSchema#integer`;\n  },\n  'http://www.w3.org/2001/XMLSchema#double'(a: number): string {\n    let str = a.toString();\n    if (!str.includes('.')) {\n      str += '.0';\n    }\n    return `\"${str}\"^^http://www.w3.org/2001/XMLSchema#double`;\n  },\n  'bound'(a: Algebra.Expression): string {\n    if (a.expressionType !== 'term') {\n      throw new Error(`BOUND expects a TermExpression but got: ${JSON.stringify(a)}`);\n    }\n    const { term } = <Algebra.TermExpression> a;\n    if (term.termType !== 'Variable') {\n      throw new Error(`BOUND expects a Variable but got: ${JSON.stringify(term)}`);\n    }\n    return this.has(termToString(term)) ? XSD_TRUE : XSD_FALSE;\n  },\n};\n\n// Tag all operators that expect their arguments to be numeric\n[\n  '+', '-', '*', '/', '<', '<=', '>', '>=',\n  XSD_INTEGER, XSD_DOUBLE,\n].forEach(operatorName => {\n  operators[operatorName].type = 'numeric';\n});\n\n// Tag all operators that expect their arguments to be boolean\n[\n  '!', '&&', '||',\n].forEach(operatorName => {\n  operators[operatorName].type = 'boolean';\n});\n\n// Tag all operators that have numeric results\n[\n  '+', '-', '*', '/',\n].forEach(operatorName => {\n  operators[operatorName].resultType = 'numeric';\n});\n\n// Tag all operators that have boolean results\n[\n  '!', '&&', '||', '=', '!=', '<', '<=', '>', '>=',\n  'langmatches', 'contains', 'regex',\n].forEach(operatorName => {\n  operators[operatorName].resultType = 'boolean';\n});\n\n// Tag all operators that take expressions instead of evaluated expressions\noperators.bound.acceptsExpressions = true;\n"]}