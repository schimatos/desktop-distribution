{"version":3,"file":"ActorQueryOperationFromQuad.js","sourceRoot":"","sources":["ActorQueryOperationFromQuad.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorQueryOperationOutput,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport type * as RDF from 'rdf-js';\nimport { Algebra, Factory } from 'sparqlalgebrajs';\n\n/**\n * A comunica From Query Operation Actor.\n */\nexport class ActorQueryOperationFromQuad extends ActorQueryOperationTypedMediated<Algebra.From> {\n  private static readonly FACTORY: Factory = new Factory();\n  private static readonly ALGEBRA_TYPES: string[] = Object.keys(Algebra.types).map(key => (<any> Algebra.types)[key]);\n\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'from');\n  }\n\n  /**\n   * Create a deep copy of the given operation.\n   * @param {Operation} operation An operation.\n   * @param {(subOperation: Operation) => Operation} recursiveCb A callback for recursive operation calls.\n   * @return {Operation} The copied operation.\n   */\n  public static copyOperation(operation: Algebra.Operation,\n    recursiveCb: (subOperation: Algebra.Operation) => Algebra.Operation): Algebra.Operation {\n    const copiedOperation: Algebra.Operation = <any> {};\n    for (const key of Object.keys(operation)) {\n      if (Array.isArray(operation[key])) {\n        if (key === 'variables') {\n          copiedOperation[key] = operation[key];\n        } else {\n          copiedOperation[key] = operation[key].map(recursiveCb);\n        }\n      } else if (ActorQueryOperationFromQuad.ALGEBRA_TYPES.includes(operation[key].type)) {\n        copiedOperation[key] = recursiveCb(operation[key]);\n      } else {\n        copiedOperation[key] = operation[key];\n      }\n    }\n    return copiedOperation;\n  }\n\n  /**\n   * Recursively transform the given operation to use the given graphs as default graph\n   * This will (possibly) create a new operation and not modify the given operation.\n   * @param {Operation} operation An operation.\n   * @param {RDF.Term[]} defaultGraphs Graph terms.\n   * @return {Operation} A new operation.\n   */\n  public static applyOperationDefaultGraph(operation: Algebra.Operation, defaultGraphs: RDF.Term[]): Algebra.Operation {\n    // If the operation is a BGP or Path, change the graph.\n    if ((operation.type === 'bgp' && operation.patterns.length > 0) || operation.type === 'path') {\n      if (operation.type === 'bgp') {\n        return ActorQueryOperationFromQuad.joinOperations(operation.patterns.map((pattern: Algebra.Pattern) => {\n          if (pattern.graph.termType !== 'DefaultGraph') {\n            return ActorQueryOperationFromQuad.FACTORY.createBgp([ pattern ]);\n          }\n          const bgps = defaultGraphs.map((graph: RDF.Term) =>\n            ActorQueryOperationFromQuad.FACTORY.createBgp([ ActorQueryOperationFromQuad.FACTORY\n              .createPattern(pattern.subject, pattern.predicate, pattern.object, graph) ]));\n          return ActorQueryOperationFromQuad.unionOperations(bgps);\n        }));\n      }\n      if (operation.graph.termType !== 'DefaultGraph') {\n        return operation;\n      }\n      const paths = defaultGraphs.map(\n        (graph: RDF.Term) => ActorQueryOperationFromQuad.FACTORY\n          .createPath(operation.subject, operation.predicate, operation.object, graph),\n      );\n      return ActorQueryOperationFromQuad.joinOperations(paths);\n    }\n\n    return ActorQueryOperationFromQuad.copyOperation(operation,\n      (subOperation: Algebra.Operation) => this.applyOperationDefaultGraph(subOperation, defaultGraphs));\n  }\n\n  /**\n   * Recursively transform the given operation to use the given graphs as named graph\n   * This will (possibly) create a new operation and not modify the given operation.\n   * @param {Operation} operation An operation.\n   * @param {RDF.Term[]} namedGraphs Graph terms.\n   * @return {Operation} A new operation.\n   */\n  public static applyOperationNamedGraph(operation: Algebra.Operation, namedGraphs: RDF.Term[],\n    defaultGraphs: RDF.Term[]): Algebra.Operation {\n    // If the operation is a BGP or Path, change the graph.\n    if ((operation.type === 'bgp' && operation.patterns.length > 0) || operation.type === 'path') {\n      let patternGraph: RDF.Term;\n      if (operation.type === 'bgp') {\n        // We assume that the BGP has at least one pattern and all have the same graph.\n        patternGraph = operation.patterns[0].graph;\n      } else {\n        patternGraph = operation.graph;\n      }\n      if (patternGraph.termType === 'DefaultGraph') {\n        // SPARQL spec (8.2) describes that when FROM NAMED's are used without a FROM, the default graph must be empty.\n        // The FROMs are transformed before this step to a named node, so this will not apply to this case anymore.\n        return { type: 'bgp', patterns: []};\n      }\n      if (patternGraph.termType === 'Variable') {\n        if (namedGraphs.length === 1) {\n          const graph: RDF.Term = namedGraphs[0];\n          // If the pattern graph is a variable, replace the graph and bind the variable using VALUES\n          const bindings: Record<string, RDF.Term> = {};\n          bindings[`?${patternGraph.value}`] = graph;\n          const values: Algebra.Values = ActorQueryOperationFromQuad.FACTORY\n            .createValues([ patternGraph ], [ bindings ]);\n          let pattern: Algebra.Operation;\n          if (operation.type === 'bgp') {\n            pattern = ActorQueryOperationFromQuad.FACTORY\n              .createBgp(operation.patterns.map((pat: Algebra.Pattern) => ActorQueryOperationFromQuad.FACTORY\n                .createPattern(pat.subject, pat.predicate, pat.object, graph)));\n          } else {\n            pattern = ActorQueryOperationFromQuad.FACTORY\n              .createPath(operation.subject, operation.predicate, operation.object, graph);\n          }\n          return ActorQueryOperationFromQuad.FACTORY.createJoin(values, pattern);\n        }\n        // If the pattern graph is a variable, take the union of the pattern applied to each available named graph\n        return ActorQueryOperationFromQuad.unionOperations(namedGraphs.map(\n          (graph: RDF.Term) => ActorQueryOperationFromQuad.applyOperationNamedGraph(\n            operation, [ graph ], defaultGraphs,\n          ),\n        ));\n      }\n      // The pattern's graph is defined (including the default graphs)\n      const isNamedGraphAvailable: boolean = namedGraphs.concat(defaultGraphs).some(\n        (namedGraph: RDF.Term) => namedGraph.equals(patternGraph),\n      );\n      if (isNamedGraphAvailable) {\n        // Return the pattern as-is if the pattern's graph was selected in a FROM NAMED\n        return operation;\n      }\n      // No-op if the pattern's graph was not selected in a FROM NAMED.\n      return { type: 'bgp', patterns: []};\n    }\n\n    return ActorQueryOperationFromQuad.copyOperation(operation,\n      (subOperation: Algebra.Operation) => this.applyOperationNamedGraph(subOperation, namedGraphs, defaultGraphs));\n  }\n\n  /**\n   * Transform the given array of operations into a join operation.\n   * @param {Operation[]} operations An array of operations, must contain at least one operation.\n   * @return {Join} A join operation.\n   */\n  public static joinOperations(operations: Algebra.Operation[]): Algebra.Operation {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n    if (operations.length === 2) {\n      return ActorQueryOperationFromQuad.FACTORY.createJoin(operations[0], operations[1]);\n    }\n    if (operations.length > 2) {\n      return ActorQueryOperationFromQuad.FACTORY.createJoin(<Algebra.Operation> operations.shift(),\n        this.joinOperations(operations));\n    }\n    throw new Error('A join can only be applied on at least one operation');\n  }\n\n  /**\n   * Transform the given array of operations into a union operation.\n   * @param {Operation[]} operations An array of operations, must contain at least one operation.\n   * @return {Union} A union operation.\n   */\n  public static unionOperations(operations: Algebra.Operation[]): Algebra.Operation {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n    if (operations.length === 2) {\n      return ActorQueryOperationFromQuad.FACTORY.createUnion(operations[0], operations[1]);\n    }\n    if (operations.length > 2) {\n      return ActorQueryOperationFromQuad.FACTORY.createUnion(<Algebra.Operation> operations.shift(),\n        this.unionOperations(operations));\n    }\n    throw new Error('A union can only be applied on at least one operation');\n  }\n\n  /**\n   * Transform an operation based on the default and named graphs in the pattern.\n   *\n   * FROM sets the default graph.\n   * If multiple are available, take the union of the operation for all of them at quad-pattern level.\n   *\n   * FROM NAMED indicates which named graphs are available.\n   * This will rewrite the query so that only triples from the given named graphs can be selected.\n   *\n   * @param {From} pattern A from operation.\n   * @return {Operation} The transformed operation.\n   */\n  public static createOperation(pattern: Algebra.From): Algebra.Operation {\n    let operation: Algebra.Operation = pattern.input;\n    if (pattern.default.length > 0) {\n      operation = ActorQueryOperationFromQuad.applyOperationDefaultGraph(operation, pattern.default);\n    }\n    if (pattern.named.length > 0) {\n      operation = ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, pattern.named, pattern.default);\n    }\n    return operation;\n  }\n\n  public async testOperation(pattern: Algebra.From, context: ActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.From, context: ActionContext): Promise<IActorQueryOperationOutput> {\n    const operation: Algebra.Operation = ActorQueryOperationFromQuad.createOperation(pattern);\n    return this.mediatorQueryOperation.mediate({ operation, context });\n  }\n}\n"]}