{"version":3,"file":"ActorQueryOperationGroup.js","sourceRoot":"","sources":["ActorQueryOperationGroup.ts"],"names":[],"mappings":";;;AAEA,uEAGuC;AAEvC,iDAA8C;AAC9C,2CAA0C;AAE1C,uCAAyC;AAEzC,+CAA4C;AAE5C;;GAEG;AACH,MAAa,wBAAyB,SAAQ,sDAA+C;IAC3F,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,OAAsB,EAAE,OAAsB;QACvE,KAAK,MAAM,SAAS,IAAI,OAAO,CAAC,UAAU,EAAE;YAC1C,yCAAyC;YACzC,MAAM,CAAC,GAAG,IAAI,wBAAa,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;SACnD;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,OAAsB,EAAE,OAAsB;QAEtE,wCAAwC;QACxC,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,GAAG,OAAO,CAAC;QACtC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC;QAC3F,MAAM,MAAM,GAAG,yCAAmB,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;QAE9D,sFAAsF;QACtF,uFAAuF;QACvF,mGAAmG;QACnG,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS;aAChC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,yBAAY,CAAC,CAAC,CAAC,CAAC;aACzB,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,yBAAY,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QAE7D,MAAM,cAAc,qBAAQ,yCAAmB,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAE,CAAC;QAEhF,wEAAwE;QACxE,kBAAkB;QAClB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,MAAM,MAAM,GAAG,IAAI,yBAAW,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;YAExD,sCAAsC;YACtC,qEAAqE;YACrE,wEAAwE;YACxE,gEAAgE;YAChE,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;gBACnC,IAAI;oBACF,MAAM,cAAc,GAAG,IAAI,6BAAa,CAAC,MAAM,CAAC,cAAc,EAAE,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;oBACxF,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,CAAC;oBAC5B,OAAO,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,cAAc,EAAE,QAAQ,EAAE,SAAS,EAAE,gBAAgB,EAAE,MAAM,CAAC,gBAAgB,EAAE,CAAC,CAAC;iBAC/G;gBAAC,OAAO,KAAc,EAAE;oBACvB,MAAM,CAAC,KAAK,CAAC,CAAC;iBACf;YACH,CAAC,CAAC,CAAC;YAEH,0DAA0D;YAC1D,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAE1C,iFAAiF;YACjF,0EAA0E;YAC1E,wDAAwD;YACxD,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,EAAE;gBAC1C,IAAI;oBACF,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;iBAClC;gBAAC,OAAO,KAAc,EAAE;oBACvB,MAAM,CAAC,KAAK,CAAC,CAAC;iBACf;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AA/DD,4DA+DC","sourcesContent":["import type { IActorQueryOperationOutputBindings,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport { ArrayIterator } from 'asynciterator';\nimport { termToString } from 'rdf-string';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { SyncEvaluator } from 'sparqlee';\n\nimport { GroupsState } from './GroupsState';\n\n/**\n * A comunica Group Query Operation Actor.\n */\nexport class ActorQueryOperationGroup extends ActorQueryOperationTypedMediated<Algebra.Group> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'group');\n  }\n\n  public async testOperation(pattern: Algebra.Group, context: ActionContext): Promise<IActorTest> {\n    for (const aggregate of pattern.aggregates) {\n      // Will throw for unsupported expressions\n      const _ = new SyncEvaluator(aggregate.expression);\n    }\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Group, context: ActionContext):\n  Promise<IActorQueryOperationOutputBindings> {\n    // Get result stream for the input query\n    const { input, aggregates } = pattern;\n    const outputRaw = await this.mediatorQueryOperation.mediate({ operation: input, context });\n    const output = ActorQueryOperation.getSafeBindings(outputRaw);\n\n    // The variables in scope are the variables on which we group, i.e. pattern.variables.\n    // For 'GROUP BY ?x, ?z', this is [?x, ?z], for 'GROUP by expr(?x) as ?e' this is [?e].\n    // But also in scope are the variables defined by the aggregations, since GROUP has to handle this.\n    const variables = pattern.variables\n      .map(x => termToString(x))\n      .concat(aggregates.map(agg => termToString(agg.variable)));\n\n    const sparqleeConfig = { ...ActorQueryOperation.getExpressionContext(context) };\n\n    // Return a new promise that completes when the stream has ended or when\n    // an error occurs\n    return new Promise((resolve, reject) => {\n      const groups = new GroupsState(pattern, sparqleeConfig);\n\n      // Phase 2: Collect aggregator results\n      // We can only return when the binding stream ends, when that happens\n      // we return the identified groups. Which are nothing more than Bindings\n      // of the grouping variables merged with the aggregate variables\n      output.bindingsStream.on('end', () => {\n        try {\n          const bindingsStream = new ArrayIterator(groups.collectResults(), { autoStart: false });\n          const { metadata } = output;\n          resolve({ type: 'bindings', bindingsStream, metadata, variables, canContainUndefs: output.canContainUndefs });\n        } catch (error: unknown) {\n          reject(error);\n        }\n      });\n\n      // Make sure to propagate any errors in the binding stream\n      output.bindingsStream.on('error', reject);\n\n      // Phase 1: Consume the stream, identify the groups and populate the aggregators.\n      // We need to bind this after the 'error' and 'end' listeners to avoid the\n      // stream having ended before those listeners are bound.\n      output.bindingsStream.on('data', bindings => {\n        try {\n          groups.consumeBindings(bindings);\n        } catch (error: unknown) {\n          reject(error);\n        }\n      });\n    });\n  }\n}\n"]}