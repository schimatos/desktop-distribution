{"version":3,"file":"GroupsState.js","sourceRoot":"","sources":["GroupsState.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbstractFilterHash } from '@comunica/actor-abstract-bindings-hash';\nimport { Bindings } from '@comunica/bus-query-operation';\nimport type { Term } from 'rdf-js';\nimport { termToString } from 'rdf-string';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { SyncEvaluatorConfig } from 'sparqlee';\nimport { AggregateEvaluator } from 'sparqlee';\n\n/**\n * A simple type alias for strings that should be hashes of Bindings\n */\nexport type BindingsHash = string;\n\n/**\n * A state container for a single group\n *\n * @property {Bindings} bindings - The binding entries on which we group\n */\nexport interface IGroup {\n  bindings: Bindings;\n  aggregators: Record<string, AggregateEvaluator>;\n}\n\n/**\n * A state manager for the groups constructed by consuming the bindings-stream.\n */\nexport class GroupsState {\n  private readonly groups: Map<BindingsHash, IGroup>;\n  private readonly groupVariables: Set<string>;\n  private readonly distinctHashes: null | Map<BindingsHash, Set<BindingsHash>>;\n\n  public constructor(private readonly pattern: Algebra.Group, private readonly sparqleeConfig: SyncEvaluatorConfig) {\n    this.groups = new Map();\n    this.groupVariables = new Set(this.pattern.variables.map(x => termToString(x)));\n    this.distinctHashes = pattern.aggregates.some(({ distinct }) => distinct) ?\n      new Map() :\n      null;\n  }\n\n  /**\n   * - Consumes a stream binding\n   * - Find the corresponding group and create one if need be\n   * - Feeds the binding to the group's aggregators\n   *\n   * @param {Bindings} bindings - The Bindings to consume\n   */\n  public consumeBindings(bindings: Bindings): void {\n    // Select the bindings on which we group\n    const grouper = bindings\n      .filter((_, variable: string) => this.groupVariables.has(variable))\n      .toMap();\n    const groupHash = this.hashBindings(grouper);\n\n    // First member of group -> create new group\n    let group: IGroup | undefined = this.groups.get(groupHash);\n    if (!group) {\n      // Initialize state for all aggregators for new group\n      const aggregators: Record<string, AggregateEvaluator> = {};\n      for (const aggregate of this.pattern.aggregates) {\n        const key = termToString(aggregate.variable);\n        aggregators[key] = new AggregateEvaluator(aggregate, this.sparqleeConfig);\n        aggregators[key].put(bindings);\n      }\n\n      group = { aggregators, bindings: grouper };\n      this.groups.set(groupHash, group);\n\n      if (this.distinctHashes) {\n        const bindingsHash = this.hashBindings(bindings);\n        this.distinctHashes.set(groupHash, new Set([ bindingsHash ]));\n      }\n    } else {\n      // Group already exists\n      // Update all the aggregators with the input binding\n      for (const aggregate of this.pattern.aggregates) {\n        // If distinct, check first wether we have inserted these values already\n        if (aggregate.distinct) {\n          const hash = this.hashBindings(bindings);\n          if ((<Set<string>> this.distinctHashes!.get(groupHash)).has(hash)) {\n            continue;\n          } else {\n            (<Set<string>> this.distinctHashes!.get(groupHash)).add(hash);\n          }\n        }\n\n        const variable = termToString(aggregate.variable);\n        group.aggregators[variable].put(bindings);\n      }\n    }\n  }\n\n  /**\n   * Collect the result of the current state. This returns a Bindings per group,\n   * and a (possibly empty) Bindings in case the no Bindings have been consumed yet.\n   */\n  public collectResults(): Bindings[] {\n    // Collect groups\n    let rows: Bindings[] = [ ...this.groups ].map(([ _, group ]) => {\n      const { bindings: groupBindings, aggregators } = group;\n\n      // Collect aggregator bindings\n      // If the aggregate errorred, the result will be undefined\n      const aggBindings: Record<string, Term> = {};\n      for (const variable in aggregators) {\n        const value = aggregators[variable].result();\n        if (value !== undefined) {\n          // Filter undefined\n          aggBindings[variable] = value;\n        }\n      }\n\n      // Merge grouping bindings and aggregator bindings\n      return groupBindings.merge(aggBindings);\n    });\n\n    // Case: No Input\n    // Some aggregators still define an output on the empty input\n    // Result is a single Bindings\n    if (rows.length === 0 && this.groupVariables.size === 0) {\n      const single: Record<string, Term> = {};\n      for (const aggregate of this.pattern.aggregates) {\n        const key = termToString(aggregate.variable);\n        const value = AggregateEvaluator.emptyValue(aggregate);\n        if (value !== undefined) {\n          single[key] = value;\n        }\n      }\n      rows = [ Bindings(single) ];\n    }\n\n    return rows;\n  }\n\n  /**\n   * @param {Bindings} bindings - Bindings to hash\n   */\n  private hashBindings(bindings: Bindings): BindingsHash {\n    return AbstractFilterHash.hash(bindings);\n  }\n}\n"]}