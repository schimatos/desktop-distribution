{"version":3,"file":"ActorQueryOperationLeftJoinLeftDeep.js","sourceRoot":"","sources":["ActorQueryOperationLeftJoinLeftDeep.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Bindings,\n  BindingsStream,\n  IActorQueryOperationOutputBindings,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated, getMetadata,\n  materializeOperation,\n} from '@comunica/bus-query-operation';\nimport { ActorRdfJoin } from '@comunica/bus-rdf-join';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport { MultiTransformIterator, TransformIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\n\n/**\n * A comunica LeftJoin left-deep Query Operation Actor.\n */\nexport class ActorQueryOperationLeftJoinLeftDeep extends ActorQueryOperationTypedMediated<Algebra.LeftJoin> {\n  private static readonly FACTORY = new Factory();\n\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'leftjoin');\n  }\n\n  /**\n   * Create a new bindings stream\n   * that takes every binding of the base stream,\n   * materializes the remaining patterns with it,\n   * and emits all bindings from this new set of patterns.\n   * @param {BindingsStream} leftStream The base stream.\n   * @param {Algebra.Operation} rightOperation The operation to materialize with each binding of the base stream.\n   * @param {Algebra.Operation => Promise<BindingsStream>} operationBinder A callback to retrieve the bindings stream\n   *                                                                       of an operation.\n   * @return {BindingsStream}\n   */\n  public static createLeftDeepStream(leftStream: BindingsStream, rightOperation: Algebra.Operation,\n    operationBinder: (operation: Algebra.Operation) => Promise<BindingsStream>): BindingsStream {\n    return new MultiTransformIterator(leftStream, {\n      multiTransform(bindings: Bindings) {\n        const bindingsMerger = (subBindings: Bindings): Bindings => subBindings.merge(bindings);\n        return new TransformIterator(\n          async() => (await operationBinder(materializeOperation(rightOperation, bindings)))\n            .map(bindingsMerger), { maxBufferSize: 128 },\n        );\n      },\n      optional: true,\n    });\n  }\n\n  public async testOperation(pattern: Algebra.LeftJoin, context: ActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.LeftJoin, context: ActionContext):\n  Promise<IActorQueryOperationOutputBindings> {\n    // Initiate left and right operations\n    // Only the left stream will be used.\n    // The right stream is ignored and only its metadata and variables are used.\n    const left = ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation\n      .mediate({ operation: pattern.left, context }));\n    const right = ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation\n      .mediate({ operation: pattern.right, context }));\n\n    // Close the right stream, since we don't need that one\n    right.bindingsStream.close();\n\n    // If an expression was defined, wrap the right operation in a filter expression.\n    const rightOperation = pattern.expression ?\n      ActorQueryOperationLeftJoinLeftDeep.FACTORY.createFilter(pattern.right, pattern.expression) :\n      pattern.right;\n\n    // Create a left-deep stream with left and right.\n    const bindingsStream = ActorQueryOperationLeftJoinLeftDeep.createLeftDeepStream(\n      left.bindingsStream,\n      rightOperation,\n      async(operation: Algebra.Operation) => ActorQueryOperation.getSafeBindings(\n        await this.mediatorQueryOperation.mediate({ operation, context }),\n      ).bindingsStream,\n    );\n\n    // Determine variables and metadata\n    const variables = ActorRdfJoin.joinVariables({ entries: [ left, right ]});\n    const metadata = (): Promise<Record<string, any>> => Promise.all([ left, right ].map(x => getMetadata(x)))\n      .then(metadatas => metadatas.reduce((acc, val) => acc * val.totalItems, 1))\n      .catch(() => Infinity)\n      .then(totalItems => ({ totalItems }));\n\n    return { type: 'bindings', bindingsStream, metadata, variables, canContainUndefs: true };\n  }\n}\n"]}