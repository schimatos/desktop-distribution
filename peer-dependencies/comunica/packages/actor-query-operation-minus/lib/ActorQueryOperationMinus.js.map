{"version":3,"file":"ActorQueryOperationMinus.js","sourceRoot":"","sources":["ActorQueryOperationMinus.ts"],"names":[],"mappings":";;;AAEA,uEAGuC;AAEvC,iDAAkD;AAElD,mDAAgD;AAEhD;;GAEG;AACH,MAAa,wBAAyB,SAAQ,sDAA+C;IAC3F,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IACvB,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,SAAwB,EAAE,OAAsB;QACzE,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,OAAsB,EAAE,OAAsB;QAEtE,MAAM,MAAM,GAAG,yCAAmB,CAAC,eAAe,CAChD,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC,CACjF,CAAC;QACF,MAAM,MAAM,GAAG,yCAAmB,CAAC,eAAe,CAChD,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,OAAO,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,CAChF,CAAC;QAEF,MAAM,OAAO,GAAa,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;QACtF,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;YACtB;;;eAGG;YACH,MAAM,KAAK,GAAkB,IAAI,6BAAa,CAAC,OAAO,CAAC,CAAC;YACxD,MAAM,cAAc,GAAG,IAAI,iCAAiB,CAAC,KAAK,IAAG,EAAE;gBACrD,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;oBAC1B,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;oBAC1D,MAAM,CAAC,cAAc,CAAC,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;gBAC3C,CAAC,CAAC,CAAC;gBACH,OAAO,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;YACrE,CAAC,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;YACzB,MAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,IAAI,MAAM,CAAC,gBAAgB,CAAC;YAC5E,OAAO;gBACL,IAAI,EAAE,UAAU;gBAChB,cAAc;gBACd,SAAS,EAAE,MAAM,CAAC,SAAS;gBAC3B,QAAQ,EAAE,MAAM,CAAC,QAAQ;gBACzB,gBAAgB;aACjB,CAAC;SACH;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACK,kBAAkB,CAAC,MAAgB,EAAE,MAAgB;QAC3D,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAC9B,CAAC,KAAa,EAAE,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAC1C,CAAC,MAAM,CAAC,CAAC,IAA6B,EAAE,GAAW,EAAE,EAAE;YACtD,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;YACjB,OAAO,IAAI,CAAC;QACd,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IACV,CAAC;CACF;AAvDD,4DAuDC","sourcesContent":["import type { IActorQueryOperationOutputBindings,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport { TransformIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { BindingsIndex } from './BindingsIndex';\n\n/**\n * A comunica Minus Query Operation Actor.\n */\nexport class ActorQueryOperationMinus extends ActorQueryOperationTypedMediated<Algebra.Minus> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'minus');\n  }\n\n  public async testOperation(operation: Algebra.Minus, context: ActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Minus, context: ActionContext):\n  Promise<IActorQueryOperationOutputBindings> {\n    const buffer = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ operation: pattern.right, context }),\n    );\n    const output = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ operation: pattern.left, context }),\n    );\n\n    const commons: string[] = this.getCommonVariables(buffer.variables, output.variables);\n    if (commons.length > 0) {\n      /**\n       * To assure we've filtered all B (`buffer`) values from A (`output`) we wait until we've fetched all values of B.\n       * Then we save these triples in `index` and use it to filter our A-stream.\n       */\n      const index: BindingsIndex = new BindingsIndex(commons);\n      const bindingsStream = new TransformIterator(async() => {\n        await new Promise(resolve => {\n          buffer.bindingsStream.on('data', data => index.add(data));\n          buffer.bindingsStream.on('end', resolve);\n        });\n        return output.bindingsStream.filter(data => !index.contains(data));\n      }, { autoStart: false });\n      const canContainUndefs = buffer.canContainUndefs || output.canContainUndefs;\n      return {\n        type: 'bindings',\n        bindingsStream,\n        variables: output.variables,\n        metadata: output.metadata,\n        canContainUndefs,\n      };\n    }\n    return output;\n  }\n\n  /**\n   * This function puts all common values between 2 arrays in a map with `value` : true\n   */\n  private getCommonVariables(array1: string[], array2: string[]): string[] {\n    return Object.keys(array1.filter(\n      (value: string) => array2.includes(value),\n    ).reduce((hash: Record<string, boolean>, key: string) => {\n      hash[key] = true;\n      return hash;\n    }, {}));\n  }\n}\n"]}