{"version":3,"file":"ActorQueryOperationOrderByDirect.js","sourceRoot":"","sources":["ActorQueryOperationOrderByDirect.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,yGAA2F;AAG3F,uEAAsG;AAEtG,2CAA0C;AAC1C,qDAA0C;AAC1C,iDAA8C;AAE9C;;GAEG;AACH,MAAa,gCAAiC,SAAQ,sDAAiD;IAGrG,YAAmB,IAA2C;;QAC5D,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;QACvB,IAAI,CAAC,MAAM,SAAG,IAAI,CAAC,MAAM,mCAAI,QAAQ,CAAC;IACxC,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,OAAwB,EAAE,OAAsB;QACzE,6CAA6C;QAC7C,KAAK,IAAI,IAAI,IAAI,OAAO,CAAC,WAAW,EAAE;YACpC,6BAA6B;YAC7B,IAAI,IAAI,CAAC,cAAc,KAAK,yBAAO,CAAC,eAAe,CAAC,QAAQ,EAAE;gBAC5D,MAAM,EAAE,GAAgC,IAAI,CAAC;gBAC7C,IAAI,EAAE,CAAC,QAAQ,KAAK,MAAM,EAAE;oBAC1B,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iBACnB;aACF;YACD,yBAAyB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;SACjD;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,OAAwB,EAAE,OAAsB;QAExE,MAAM,MAAM,GACV,yCAAmB,CAAC,eAAe,CAAC,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAC3E,EAAE,SAAS,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,CACtC,CAAC,CAAC;QAEL,MAAM,OAAO,GAAG,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC;QACxC,IAAI,EAAE,cAAc,EAAE,GAAG,MAAM,CAAC;QAChC,KAAK,IAAI,IAAI,IAAI,OAAO,CAAC,WAAW,EAAE;YACpC,IAAI,SAAS,GAAG,IAAI,CAAC;YACrB,IAAI,IAAI,CAAC,cAAc,KAAK,yBAAO,CAAC,eAAe,CAAC,QAAQ,EAAE;gBAC5D,MAAM,EAAE,GAAgC,IAAI,CAAC;gBAC7C,IAAI,EAAE,CAAC,QAAQ,KAAK,MAAM,EAAE;oBAC1B,SAAS,GAAG,KAAK,CAAC;oBAClB,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iBACnB;aACF;YACD,MAAM,KAAK,GAAG,yBAAyB,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;YAC9D,cAAc,GAAG,IAAI,2BAAY,CAAC,cAAc,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;gBAChE,MAAM,MAAM,GAAG,yBAAY,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACzC,MAAM,MAAM,GAAG,yBAAY,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC1C,IAAI,CAAC,MAAM,IAAI,CAAC,MAAM,EAAE;oBACtB,OAAO,CAAC,CAAC;iBACV;gBACD,OAAO,MAAM,GAAG,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAChD,CAAC,EAAE,OAAO,CAAC,CAAC;SACb;QAED,OAAO;YACL,IAAI,EAAE,UAAU;YAChB,cAAc;YACd,QAAQ,EAAE,MAAM,CAAC,QAAQ;YACzB,SAAS,EAAE,MAAM,CAAC,SAAS;YAC3B,gBAAgB,EAAE,MAAM,CAAC,gBAAgB;SAC1C,CAAC;IACJ,CAAC;CACF;AA5DD,4EA4DC","sourcesContent":["import * as SparqlExpressionEvaluator from '@comunica/actor-query-operation-filter-direct';\nimport type { IActorQueryOperationOutputBindings,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperation, ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport { termToString } from 'rdf-string';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { SortIterator } from './SortIterator';\n\n/**\n * A comunica OrderBy Direct Query Operation Actor.\n */\nexport class ActorQueryOperationOrderByDirect extends ActorQueryOperationTypedMediated<Algebra.OrderBy> {\n  private readonly window: number;\n\n  public constructor(args: IActorQueryOperationOrderByDirectArgs) {\n    super(args, 'orderby');\n    this.window = args.window ?? Infinity;\n  }\n\n  public async testOperation(pattern: Algebra.OrderBy, context: ActionContext): Promise<IActorTest> {\n    // Will throw error for unsupported operators\n    for (let expr of pattern.expressions) {\n      // Remove descending operator\n      if (expr.expressionType === Algebra.expressionTypes.OPERATOR) {\n        const op = <Algebra.OperatorExpression> expr;\n        if (op.operator === 'desc') {\n          expr = op.args[0];\n        }\n      }\n      SparqlExpressionEvaluator.createEvaluator(expr);\n    }\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.OrderBy, context: ActionContext):\n  Promise<IActorQueryOperationOutputBindings> {\n    const output: IActorQueryOperationOutputBindings =\n      ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate(\n        { operation: pattern.input, context },\n      ));\n\n    const options = { window: this.window };\n    let { bindingsStream } = output;\n    for (let expr of pattern.expressions) {\n      let ascending = true;\n      if (expr.expressionType === Algebra.expressionTypes.OPERATOR) {\n        const op = <Algebra.OperatorExpression> expr;\n        if (op.operator === 'desc') {\n          ascending = false;\n          expr = op.args[0];\n        }\n      }\n      const order = SparqlExpressionEvaluator.createEvaluator(expr);\n      bindingsStream = new SortIterator(bindingsStream, (left, right) => {\n        const orderA = termToString(order(left));\n        const orderB = termToString(order(right));\n        if (!orderA || !orderB) {\n          return 0;\n        }\n        return orderA > orderB === ascending ? 1 : -1;\n      }, options);\n    }\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: output.metadata,\n      variables: output.variables,\n      canContainUndefs: output.canContainUndefs,\n    };\n  }\n}\n\n/**\n * The window parameter determines how many of the elements to consider when sorting.\n */\nexport interface IActorQueryOperationOrderByDirectArgs extends IActorQueryOperationTypedMediatedArgs {\n  window?: number;\n}\n"]}