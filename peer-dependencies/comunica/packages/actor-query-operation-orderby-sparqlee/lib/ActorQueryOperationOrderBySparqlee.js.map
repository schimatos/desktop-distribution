{"version":3,"file":"ActorQueryOperationOrderBySparqlee.js","sourceRoot":"","sources":["ActorQueryOperationOrderBySparqlee.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Bindings, IActorQueryOperationOutputBindings,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation, ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport type { Term } from 'rdf-js';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { AsyncEvaluator, isExpressionError, orderTypes } from 'sparqlee';\n\nimport { SortIterator } from './SortIterator';\n\n/**\n * A comunica OrderBy Sparqlee Query Operation Actor.\n */\nexport class ActorQueryOperationOrderBySparqlee extends ActorQueryOperationTypedMediated<Algebra.OrderBy> {\n  private readonly window: number;\n\n  public constructor(args: IActorQueryOperationOrderBySparqleeArgs) {\n    super(args, 'orderby');\n    this.window = args.window ?? Infinity;\n  }\n\n  public async testOperation(pattern: Algebra.OrderBy, context: ActionContext): Promise<IActorTest> {\n    // Will throw error for unsupported operators\n    for (let expr of pattern.expressions) {\n      expr = this.extractSortExpression(expr);\n      const _ = new AsyncEvaluator(expr);\n    }\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.OrderBy, context: ActionContext):\n  Promise<IActorQueryOperationOutputBindings> {\n    const outputRaw = await this.mediatorQueryOperation.mediate({ operation: pattern.input, context });\n    const output = ActorQueryOperation.getSafeBindings(outputRaw);\n\n    const options = { window: this.window };\n    const sparqleeConfig = { ...ActorQueryOperation.getExpressionContext(context) };\n    let { bindingsStream } = output;\n\n    // Sorting backwards since the first one is the most important therefore should be ordered last.\n    for (let i = pattern.expressions.length - 1; i >= 0; i--) {\n      let expr = pattern.expressions[i];\n      const isAscending = this.isAscending(expr);\n      expr = this.extractSortExpression(expr);\n      // Transform the stream by annotating it with the expr result\n      const evaluator = new AsyncEvaluator(expr, sparqleeConfig);\n      interface IAnnotatedBinding {\n        bindings: Bindings; result: Term | undefined;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-loop-func\n      const transform = async(bindings: Bindings, next: any, push: (result: IAnnotatedBinding) => void):\n      Promise<void> => {\n        try {\n          const result = await evaluator.evaluate(bindings);\n          push({ bindings, result });\n        } catch (error: unknown) {\n          if (!isExpressionError(<Error> error)) {\n            bindingsStream.emit('error', error);\n          }\n          push({ bindings, result: undefined });\n        }\n        next();\n      };\n      const transformedStream = bindingsStream.transform<IAnnotatedBinding>({ transform });\n\n      // Sort the annoted stream\n      const sortedStream = new SortIterator(transformedStream,\n        (left, right) => orderTypes(left.result, right.result, isAscending),\n        options);\n\n      // Remove the annotation\n      bindingsStream = sortedStream.map(({ bindings, result }) => bindings);\n    }\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: output.metadata,\n      variables: output.variables,\n      canContainUndefs: output.canContainUndefs,\n    };\n  }\n\n  // Remove descending operator if necessary\n  private extractSortExpression(expr: Algebra.Expression): Algebra.Expression {\n    const { expressionType, operator } = expr;\n    if (expressionType !== Algebra.expressionTypes.OPERATOR) {\n      return expr;\n    }\n    return operator === 'desc' ?\n      expr.args[0] :\n      expr;\n  }\n\n  private isAscending(expr: Algebra.Expression): boolean {\n    const { expressionType, operator } = expr;\n    if (expressionType !== Algebra.expressionTypes.OPERATOR) {\n      return true;\n    }\n    return operator !== 'desc';\n  }\n}\n\n/**\n * The window parameter determines how many of the elements to consider when sorting.\n */\nexport interface IActorQueryOperationOrderBySparqleeArgs extends IActorQueryOperationTypedMediatedArgs {\n  window?: number;\n}\n"]}