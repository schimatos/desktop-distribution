{"version":3,"file":"ActorQueryOperationPathZeroOrMore.js","sourceRoot":"","sources":["ActorQueryOperationPathZeroOrMore.ts"],"names":[],"mappings":"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","sourcesContent":["import { ActorAbstractPath } from '@comunica/actor-abstract-path';\nimport type { IActorQueryOperationOutputBindings,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  Bindings,\n  ActorQueryOperation,\n} from '@comunica/bus-query-operation';\nimport type { ActionContext } from '@comunica/core';\nimport { MultiTransformIterator, TransformIterator, EmptyIterator, BufferedIterator } from 'asynciterator';\nimport type { Variable } from 'rdf-js';\nimport { termToString } from 'rdf-string';\nimport { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Path ZeroOrMore Query Operation Actor.\n */\nexport class ActorQueryOperationPathZeroOrMore extends ActorAbstractPath {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, Algebra.types.ZERO_OR_MORE_PATH);\n  }\n\n  public async runOperation(path: Algebra.Path, context: ActionContext): Promise<IActorQueryOperationOutputBindings> {\n    const distinct = await this.isPathArbitraryLengthDistinct(context, path);\n    if (distinct.operation) {\n      return distinct.operation;\n    }\n\n    context = distinct.context;\n\n    const predicate = <Algebra.ZeroOrMorePath> path.predicate;\n\n    const sVar = path.subject.termType === 'Variable';\n    const oVar = path.object.termType === 'Variable';\n    const gVar = path.graph.termType === 'Variable';\n\n    if (sVar && oVar) {\n      // Query ?s ?p ?o, to get all possible namedNodes in de the db\n      const predVar = this.generateVariable(path);\n      const single = ActorAbstractPath.FACTORY.createPattern(path.subject, predVar, path.object, path.graph);\n      const results = ActorQueryOperation.getSafeBindings(\n        await this.mediatorQueryOperation.mediate({ context, operation: single }),\n      );\n      const subjectString = termToString(path.subject);\n      const objectString = termToString(path.object);\n\n      // Set with all namedNodes we have already started a predicate* search from\n      const entities: Set<string> = new Set();\n\n      const termHashes = {};\n\n      const bindingsStream: MultiTransformIterator<Bindings, Bindings> = new MultiTransformIterator(\n        results.bindingsStream,\n        {\n          multiTransform: (bindings: Bindings) => {\n            // Get the subject and object of the triples (?s ?p ?o) and extract graph if it was a variable\n            const subject = bindings.get(subjectString);\n            const object = bindings.get(objectString);\n            const graph = gVar ? bindings.get(termToString(path.graph)) : path.graph;\n            // Make a hash of namedNode + graph to remember from where we already started a search\n            const subjectGraphHash = termToString(subject) + termToString(graph);\n            const objectGraphHash = termToString(object) + termToString(graph);\n            return new TransformIterator<Bindings>(\n              async() => {\n                // If no new namedNodes in this triple, return nothing\n                if (entities.has(subjectGraphHash) && entities.has(objectGraphHash)) {\n                  return new EmptyIterator();\n                }\n                // Set up an iterator to which getSubjectAndObjectBindingsPredicateStar will push solutions\n                const it = new BufferedIterator<Bindings>();\n                const counter = { count: 0 };\n                // If not started from this namedNode (subject in triple) in this graph, start a search\n                if (!entities.has(subjectGraphHash)) {\n                  entities.add(subjectGraphHash);\n                  await this.getSubjectAndObjectBindingsPredicateStar(\n                    subjectString,\n                    objectString,\n                    subject,\n                    subject,\n                    predicate.path,\n                    graph,\n                    context,\n                    termHashes,\n                    {},\n                    it,\n                    counter,\n                  );\n                }\n                // If not started from this namedNode (object in triple) in this graph, start a search\n                if (!entities.has(objectGraphHash)) {\n                  entities.add(objectGraphHash);\n                  await this.getSubjectAndObjectBindingsPredicateStar(\n                    subjectString,\n                    objectString,\n                    object,\n                    object,\n                    predicate.path,\n                    graph,\n                    context,\n                    termHashes,\n                    {},\n                    it,\n                    counter,\n                  );\n                }\n                return it.transform<Bindings>({\n                  transform(item, next, push) {\n                    // If the graph was a variable, fill in it's binding (we got it from the ?s ?p ?o binding)\n                    if (gVar) {\n                      item = item.set(termToString(path.graph), graph);\n                    }\n                    push(item);\n                    next();\n                  },\n                });\n              },\n            );\n          },\n        },\n      );\n      const variables = gVar ?\n        [ subjectString, objectString, termToString(path.graph) ] :\n        [ subjectString, objectString ];\n      return { type: 'bindings', bindingsStream, variables, canContainUndefs: false };\n    }\n    if (!sVar && !oVar) {\n      const variable = this.generateVariable();\n      const bindingsStream = (await this.getObjectsPredicateStarEval(\n        path.subject,\n        variable,\n        predicate.path,\n        path.graph,\n        context,\n      ))\n        .transform<Bindings>({\n        filter: item => item.get(termToString(variable)).equals(path.object),\n        transform(item, next, push) {\n          // Return graph binding if graph was a variable, otherwise empty binding\n          const binding = gVar ?\n            Bindings({ [termToString(path.graph)]: item.get(termToString(path.graph)) }) :\n            Bindings({});\n          push(binding);\n          next();\n        },\n      });\n      return {\n        type: 'bindings',\n        bindingsStream,\n        variables: gVar ? [ termToString(path.graph) ] : [],\n        canContainUndefs: false,\n      };\n    }\n    // If (sVar || oVar)\n    const subject = sVar ? path.object : path.subject;\n    const value: Variable = <Variable> (sVar ? path.subject : path.object);\n    const pred = sVar ? ActorAbstractPath.FACTORY.createInv(predicate.path) : predicate.path;\n    const bindingsStream = (await this.getObjectsPredicateStarEval(\n      subject,\n      value,\n      pred,\n      path.graph,\n      context,\n    ))\n      .transform<Bindings>({\n      transform(item, next, push) {\n        push(item);\n        next();\n      },\n    });\n    const variables = gVar ? [ termToString(value), termToString(path.graph) ] : [ termToString(value) ];\n    return { type: 'bindings', bindingsStream, variables, canContainUndefs: false };\n  }\n}\n"]}