{"version":3,"file":"ActorQueryOperationProject.js","sourceRoot":"","sources":["ActorQueryOperationProject.ts"],"names":[],"mappings":";;;AAEA,uEAAsG;AAEtG,yDAAyD;AACzD,uDAA+C;AAC/C,2CAA0C;AAE1C,MAAM,EAAE,GAAG,IAAI,8BAAW,EAAE,CAAC;AAE7B;;GAEG;AACH,MAAa,0BAA2B,SAAQ,sDAAiD;IAC/F,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,OAAwB,EAAE,OAAsB;QACzE,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,OAAwB,EAAE,OAAsB;QAExE,oBAAoB;QACpB,MAAM,MAAM,GAAuC,yCAAmB,CAAC,eAAe,CACpF,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,CAAC,CACjF,CAAC;QAEF,mEAAmE;QACnE,MAAM,SAAS,GAAa,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,yBAAY,CAAC,CAAC,CAAC,CAAC,CAAC;QACxE,MAAM,eAAe,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;QAE3F,uEAAuE;QACvE,MAAM,gBAAgB,GAAG,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC;QAC5F,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,cAAc,gBAAgB,4DAA4D,CAAC,CAAC;SAC7G;QAED,2FAA2F;QAC3F,IAAI,cAAc,GAAmB,eAAe,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;YACjE,MAAM,CAAC,cAAc,CAAC,CAAC;YACvB,MAAM,CAAC,cAAc,CAAC,SAAS,CAAC;gBAC9B,GAAG,CAAC,QAAkB;oBACpB,KAAK,MAAM,cAAc,IAAI,eAAe,EAAE;wBAC5C,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;qBAC5C;oBACD,OAAO,QAAQ,CAAC;gBAClB,CAAC;gBACD,SAAS,EAAE,KAAK;aACjB,CAAC,CAAC;QAEL,iHAAiH;QACjH,sFAAsF;QACtF,kFAAkF;QAClF,IAAI,gBAAgB,GAAG,CAAC,CAAC;QACzB,cAAc,GAAG,cAAc,CAAC,SAAS,CAAC;YACxC,GAAG,CAAC,QAAkB;gBACpB,gBAAgB,EAAE,CAAC;gBACnB,OAAkB,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;oBACpC,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE;wBACzC,IAAI,IAAI,YAAY,8BAAe,EAAE;4BACnC,OAAO,IAAI,8BAAe,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,gBAAgB,EAAE,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;yBACjF;wBACD,OAAO,EAAE,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,gBAAgB,EAAE,CAAC,CAAC;qBACzD;oBACD,OAAO,IAAI,CAAC;gBACd,CAAC,CAAC,CAAC;YACL,CAAC;YACD,SAAS,EAAE,KAAK;SACjB,CAAC,CAAC;QAEH,OAAO;YACL,IAAI,EAAE,UAAU;YAChB,cAAc;YACd,QAAQ,EAAE,MAAM,CAAC,QAAQ;YACzB,SAAS;YACT,gBAAgB,EAAE,MAAM,CAAC,gBAAgB;SAC1C,CAAC;IACJ,CAAC;CACF;AAnED,gEAmEC","sourcesContent":["import type { Bindings, BindingsStream,\n  IActorQueryOperationOutputBindings, IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperation, ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport { BlankNodeScoped } from '@comunica/data-factory';\nimport { DataFactory } from 'rdf-data-factory';\nimport { termToString } from 'rdf-string';\nimport type { Algebra } from 'sparqlalgebrajs';\nconst DF = new DataFactory();\n\n/**\n * A comunica Project Query Operation Actor.\n */\nexport class ActorQueryOperationProject extends ActorQueryOperationTypedMediated<Algebra.Project> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'project');\n  }\n\n  public async testOperation(pattern: Algebra.Project, context: ActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Project, context: ActionContext):\n  Promise<IActorQueryOperationOutputBindings> {\n    // Resolve the input\n    const output: IActorQueryOperationOutputBindings = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ operation: pattern.input, context }),\n    );\n\n    // Find all variables that should be deleted from the input stream.\n    const variables: string[] = pattern.variables.map(x => termToString(x));\n    const deleteVariables = output.variables.filter(variable => !variables.includes(variable));\n\n    // Error if there are variables that are not bound in the input stream.\n    const missingVariables = variables.filter(variable => !output.variables.includes(variable));\n    if (missingVariables.length > 0) {\n      throw new Error(`Variables '${missingVariables}' are used in the projection result, but are not assigned.`);\n    }\n\n    // Make sure the project variables are the only variables that are present in the bindings.\n    let bindingsStream: BindingsStream = deleteVariables.length === 0 ?\n      output.bindingsStream :\n      output.bindingsStream.transform({\n        map(bindings: Bindings) {\n          for (const deleteVariable of deleteVariables) {\n            bindings = bindings.delete(deleteVariable);\n          }\n          return bindings;\n        },\n        autoStart: false,\n      });\n\n    // Make sure that blank nodes with same labels are not reused over different bindings, as required by SPARQL 1.1.\n    // Required for the BNODE() function: https://www.w3.org/TR/sparql11-query/#func-bnode\n    // When we have a scoped blank node, make sure the skolemized value is maintained.\n    let blankNodeCounter = 0;\n    bindingsStream = bindingsStream.transform({\n      map(bindings: Bindings) {\n        blankNodeCounter++;\n        return <Bindings> bindings.map(term => {\n          if (term && term.termType === 'BlankNode') {\n            if (term instanceof BlankNodeScoped) {\n              return new BlankNodeScoped(`${term.value}${blankNodeCounter}`, term.skolemized);\n            }\n            return DF.blankNode(`${term.value}${blankNodeCounter}`);\n          }\n          return term;\n        });\n      },\n      autoStart: false,\n    });\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: output.metadata,\n      variables,\n      canContainUndefs: output.canContainUndefs,\n    };\n  }\n}\n"]}