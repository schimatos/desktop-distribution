{"version":3,"file":"ActorQueryOperationQuadpattern.js","sourceRoot":"","sources":["ActorQueryOperationQuadpattern.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BindingsStream,\n  IActionQueryOperation, IActorQueryOperationOutput,\n  IActorQueryOperationOutputBindings } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTyped, Bindings } from '@comunica/bus-query-operation';\nimport type { IActionRdfResolveQuadPattern,\n  IActorRdfResolveQuadPatternOutput } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport type { ActionContext, Actor, IActorArgs, IActorTest, Mediator } from '@comunica/core';\nimport type { AsyncIterator } from 'asynciterator';\nimport { TransformIterator } from 'asynciterator';\nimport type * as RDF from 'rdf-js';\nimport { termToString } from 'rdf-string';\nimport type { QuadTermName } from 'rdf-terms';\nimport { getTerms, QUAD_TERM_NAMES, reduceTerms, TRIPLE_TERM_NAMES, uniqTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica actor for handling 'quadpattern' query operations.\n */\nexport class ActorQueryOperationQuadpattern extends ActorQueryOperationTyped<Algebra.Pattern>\n  implements IActorQueryOperationQuadpatternArgs {\n  public readonly mediatorResolveQuadPattern: Mediator<Actor<IActionRdfResolveQuadPattern, IActorTest,\n  IActorRdfResolveQuadPatternOutput>, IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput>;\n\n  public constructor(args: IActorQueryOperationQuadpatternArgs) {\n    super(args, 'pattern');\n  }\n\n  /**\n   * Check if a term is a variable.\n   * @param {RDF.Term} term An RDF term.\n   * @return {any} If the term is a variable or blank node.\n   */\n  public static isTermVariable(term: RDF.Term): any {\n    return term.termType === 'Variable';\n  }\n\n  /**\n   * Get all variables in the given pattern.\n   * No duplicates are returned.\n   * @param {RDF.BaseQuad} pattern A quad pattern.\n   * @return {string[]} The variables in this pattern, with '?' prefix.\n   */\n  public static getVariables(pattern: RDF.BaseQuad): string[] {\n    return uniqTerms(getTerms(pattern)\n      .filter(ActorQueryOperationQuadpattern.isTermVariable))\n      .map(x => termToString(x));\n  }\n\n  /**\n   * A helper function to find a hash with quad elements that have duplicate variables.\n   *\n   * @param {RDF.Quad} pattern A quad pattern.\n   *\n   * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns undefined.\n   *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')\n   *                                   to the list of quad elements it shares a variable name with.\n   *                                   If no links for a certain element exist, this element will\n   *                                   not be included in the hash.\n   *                                   Note 1: Quad elements will never have a link to themselves.\n   *                                           So this can never occur: { subject: [ 'subject'] },\n   *                                           instead 'null' would be returned.\n   *                                   Note 2: Links only exist in one direction,\n   *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }\n   *                                           will not occur, instead only { subject: [ 'predicate'] }\n   *                                           will be returned.\n   */\n  public static getDuplicateElementLinks(pattern: RDF.BaseQuad): Record<string, string[]> | undefined {\n    // Collect a variable to quad elements mapping.\n    const variableElements: Record<string, string[]> = {};\n    let duplicateVariables = false;\n    for (const key of QUAD_TERM_NAMES) {\n      if (pattern[key].termType === 'Variable') {\n        const val = termToString(pattern[key]);\n        const length = (variableElements[val] || (variableElements[val] = [])).push(key);\n        duplicateVariables = duplicateVariables || length > 1;\n      }\n    }\n\n    if (!duplicateVariables) {\n      return;\n    }\n\n    // Collect quad element to elements with equal variables mapping.\n    const duplicateElementLinks: Record<string, string[]> = {};\n    for (const variable in variableElements) {\n      const elements = variableElements[variable];\n      const remainingElements = elements.slice(1);\n      // Only store the elements that have at least one equal element.\n      if (remainingElements.length > 0) {\n        duplicateElementLinks[elements[0]] = remainingElements;\n      }\n    }\n\n    return duplicateElementLinks;\n  }\n\n  /**\n   * Get the metadata of the given action on a quad stream.\n   *\n   * @param {AsyncIterator<Quad>} data The data stream that is guaranteed to emit the metadata property.\n   * @return {() => Promise<{[p: string]: any}>} A lazy promise behind a callback resolving to a metadata object.\n   */\n  protected static getMetadata(data: AsyncIterator<RDF.Quad>): () => Promise<Record<string, any>> {\n    return () => new Promise((resolve, reject) => {\n      data.getProperty('metadata', (metadata: Record<string, any>) => resolve(metadata));\n      data.on('error', reject);\n    });\n  }\n\n  public async testOperation(operation: Algebra.Pattern, context?: Record<string, any>): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Pattern, context: ActionContext):\n  Promise<IActorQueryOperationOutputBindings> {\n    // Apply the (optional) pattern-specific context\n    if (pattern.context) {\n      context = context ? context.merge(pattern.context) : pattern.context;\n    }\n\n    // Resolve the quad pattern\n    const result = await this.mediatorResolveQuadPattern.mediate({ pattern, context });\n\n    // Collect all variables from the pattern\n    const variables: string[] = ActorQueryOperationQuadpattern.getVariables(pattern);\n\n    // Create the metadata callback\n    const metadata = ActorQueryOperationQuadpattern.getMetadata(result.data);\n\n    // Convenience datastructure for mapping quad elements to variables\n    const elementVariables: Record<string, string> = reduceTerms(pattern,\n      (acc: Record<string, string>, term: RDF.Term, key: QuadTermName) => {\n        if (ActorQueryOperationQuadpattern.isTermVariable(term)) {\n          acc[key] = termToString(term);\n        }\n        return acc;\n      },\n      {});\n    const quadBindingsReducer = (acc: Record<string, RDF.Term>, term: RDF.Term, key: QuadTermName):\n    Record<string, RDF.Term> => {\n      const variable: string = elementVariables[key];\n      if (variable) {\n        acc[variable] = term;\n      }\n      return acc;\n    };\n\n    // Optionally filter, and construct bindings\n    const bindingsStream: BindingsStream = new TransformIterator(async() => {\n      let filteredOutput = result.data;\n\n      // Detect duplicate variables in the pattern\n      const duplicateElementLinks: Record<string, string[]> | undefined = ActorQueryOperationQuadpattern\n        .getDuplicateElementLinks(pattern);\n\n      // If there are duplicate variables in the search pattern,\n      // make sure that we filter out the triples that don't have equal values for those triple elements,\n      // as QPF ignores variable names.\n      if (duplicateElementLinks) {\n        filteredOutput = filteredOutput.filter(quad => {\n          // No need to check the graph, because an equal element already would have to be found in s, p, or o.\n          for (const element1 of TRIPLE_TERM_NAMES) {\n            for (const element2 of duplicateElementLinks[element1] || []) {\n              if (!(<any> quad)[element1].equals((<any> quad)[element2])) {\n                return false;\n              }\n            }\n          }\n          return true;\n        });\n      }\n\n      return filteredOutput.map(quad => Bindings(reduceTerms(quad, quadBindingsReducer, {})),\n        { autoStart: true, maxBufferSize: 128 });\n    }, { autoStart: false });\n\n    return { type: 'bindings', bindingsStream, variables, metadata, canContainUndefs: false };\n  }\n}\n\nexport interface IActorQueryOperationQuadpatternArgs extends\n  IActorArgs<IActionQueryOperation, IActorTest, IActorQueryOperationOutput> {\n  mediatorResolveQuadPattern: Mediator<Actor<IActionRdfResolveQuadPattern, IActorTest,\n  IActorRdfResolveQuadPatternOutput>, IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput>;\n}\n"]}