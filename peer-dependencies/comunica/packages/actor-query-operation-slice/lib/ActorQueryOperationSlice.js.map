{"version":3,"file":"ActorQueryOperationSlice.js","sourceRoot":"","sources":["ActorQueryOperationSlice.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorQueryOperationOutputBindings, IActorQueryOperationOutputQuads,\n  IActorQueryOperationOutputStream,\n  IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport type { ActionContext, IActorTest } from '@comunica/core';\nimport type { AsyncIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Slice Query Operation Actor.\n */\nexport class ActorQueryOperationSlice extends ActorQueryOperationTypedMediated<Algebra.Slice> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'slice');\n  }\n\n  public async testOperation(pattern: Algebra.Slice, context: ActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Slice, context: ActionContext): Promise<IActorQueryOperationOutputStream> {\n    // Resolve the input\n    const output: IActorQueryOperationOutputStream = await this.mediatorQueryOperation\n      .mediate({ operation: pattern.input, context });\n\n    const metadata = this.sliceMetadata(output, pattern);\n\n    if (output.type === 'bindings') {\n      const bindingsOutput = <IActorQueryOperationOutputBindings> output;\n      const bindingsStream = this.sliceStream(bindingsOutput.bindingsStream, pattern);\n      return <IActorQueryOperationOutputBindings> {\n        type: 'bindings',\n        bindingsStream,\n        metadata,\n        variables: bindingsOutput.variables,\n        canContainUndefs: bindingsOutput.canContainUndefs,\n      };\n    }\n\n    if (output.type === 'quads') {\n      const quadOutput = <IActorQueryOperationOutputQuads> output;\n      const quadStream = this.sliceStream(quadOutput.quadStream, pattern);\n      return <IActorQueryOperationOutputQuads> { type: 'quads', quadStream, metadata };\n    }\n\n    throw new Error(`Invalid query output type: Expected 'bindings' or 'quads' but got '${output.type}'`);\n  }\n\n  // Slice the stream based on the pattern values\n  private sliceStream(stream: AsyncIterator<any>, pattern: Algebra.Slice): AsyncIterator<any> {\n    const hasLength: boolean = Boolean(pattern.length) || pattern.length === 0;\n    const { start } = pattern;\n    const end = hasLength ? pattern.start + (<number> pattern.length) - 1 : Infinity;\n    return stream.transform({ offset: start, limit: Math.max(end - start + 1, 0), autoStart: false });\n  }\n\n  // If we find metadata, apply slicing on the total number of items\n  private sliceMetadata(output: IActorQueryOperationOutputStream, pattern: Algebra.Slice):\n  (() => Promise<Record<string, any>>) | undefined {\n    const hasLength: boolean = Boolean(pattern.length) || pattern.length === 0;\n    return !output.metadata ?\n      undefined :\n      () => (<() => Promise<Record<string, any>>>output.metadata)()\n        .then(subMetadata => {\n          let { totalItems } = subMetadata;\n          if (Number.isFinite(totalItems)) {\n            totalItems = Math.max(0, totalItems - pattern.start);\n            if (hasLength) {\n              totalItems = Math.min(totalItems, <number>pattern.length);\n            }\n          }\n          return { ...subMetadata, totalItems };\n        });\n  }\n}\n"]}