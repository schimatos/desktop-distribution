{"version":3,"file":"ActorQueryOperationSparqlEndpoint.js","sourceRoot":"","sources":["ActorQueryOperationSparqlEndpoint.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EventEmitter } from 'events';\nimport type { IActionHttp, IActorHttpOutput } from '@comunica/bus-http';\nimport type { IActionQueryOperation,\n  IActorQueryOperationOutput,\n  IActorQueryOperationOutputBindings,\n  IActorQueryOperationOutputBoolean,\n  IActorQueryOperationOutputQuads } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  Bindings,\n} from '@comunica/bus-query-operation';\nimport { getDataSourceType, getDataSourceValue } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport type { ActionContext, Actor, IActorArgs, IActorTest, Mediator } from '@comunica/core';\nimport type { IMediatorTypeHttpRequests } from '@comunica/mediatortype-httprequests';\nimport { DataSourceUtils } from '@comunica/utils-datasource';\nimport { wrap } from 'asynciterator';\nimport { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport type * as RDF from 'rdf-js';\nimport { termToString } from 'rdf-string';\nimport { Factory, toSparql, Util } from 'sparqlalgebrajs';\n\n/**\n * A comunica SPARQL Endpoint Query Operation Actor.\n */\nexport class ActorQueryOperationSparqlEndpoint extends ActorQueryOperation {\n  protected static readonly FACTORY: Factory = new Factory();\n\n  public readonly mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n\n  public readonly endpointFetcher: SparqlEndpointFetcher;\n\n  protected lastContext?: ActionContext;\n\n  public constructor(args: IActorQueryOperationSparqlEndpointArgs) {\n    super(args);\n    this.endpointFetcher = new SparqlEndpointFetcher({\n      fetch: (input: Request | string, init?: RequestInit) => this.mediatorHttp.mediate(\n        { input, init, context: this.lastContext },\n      ),\n      prefixVariableQuestionMark: true,\n    });\n  }\n\n  public async test(action: IActionQueryOperation): Promise<IMediatorTypeHttpRequests> {\n    if (!action.operation) {\n      throw new Error('Missing field \\'operation\\' in a query operation action.');\n    }\n    const source = await DataSourceUtils.getSingleSource(action.context);\n    if (source && getDataSourceType(source) === 'sparql') {\n      return { httpRequests: 1 };\n    }\n    throw new Error(`${this.name} requires a single source with a 'sparql' endpoint to be present in the context.`);\n  }\n\n  public async run(action: IActionQueryOperation): Promise<IActorQueryOperationOutput> {\n    const source = await DataSourceUtils.getSingleSource(action.context);\n    if (!source) {\n      throw new Error('Illegal state: undefined sparql endpoint source.');\n    }\n    const endpoint: string = <string> getDataSourceValue(source);\n    this.lastContext = action.context;\n\n    // Determine the full SPARQL query that needs to be sent to the endpoint\n    // Also check the type of the query (SELECT, CONSTRUCT (includes DESCRIBE) or ASK)\n    let query: string | undefined;\n    let type: 'SELECT' | 'CONSTRUCT' | 'ASK' | 'UNKNOWN' | undefined;\n    let variables: RDF.Variable[] | undefined;\n    try {\n      query = toSparql(action.operation);\n      // This will throw an error in case the result is an invalid SPARQL query\n      type = this.endpointFetcher.getQueryType(query);\n    } catch {\n      // Ignore errors\n    }\n    // If the input is an sub-query, wrap this in a SELECT\n    if (!type || type === 'UNKNOWN') {\n      variables = Util.inScopeVariables(action.operation);\n      query = toSparql(ActorQueryOperationSparqlEndpoint.FACTORY.createProject(action.operation, variables));\n      type = 'SELECT';\n    }\n\n    // Execute the query against the endpoint depending on the type\n    switch (type) {\n      case 'SELECT':\n        if (!variables) {\n          variables = Util.inScopeVariables(action.operation);\n        }\n        return this.executeQuery(endpoint, <string> query, false, variables);\n      case 'CONSTRUCT':\n        return this.executeQuery(endpoint, <string> query, true);\n      case 'ASK':\n        return <IActorQueryOperationOutputBoolean>{\n          type: 'boolean',\n          booleanResult: this.endpointFetcher.fetchAsk(endpoint, <string> query),\n        };\n    }\n  }\n\n  /**\n   * Execute the given SELECT or CONSTRUCT query against the given endpoint.\n   * @param endpoint A SPARQL endpoint URL.\n   * @param query A SELECT or CONSTRUCT query.\n   * @param quads If the query returns quads, i.e., if it is a CONSTRUCT query.\n   * @param variables Variables for SELECT queries.\n   */\n  public executeQuery(endpoint: string, query: string, quads: boolean, variables?: RDF.Variable[]):\n  IActorQueryOperationOutput {\n    const inputStream: Promise<EventEmitter> = quads ?\n      this.endpointFetcher.fetchTriples(endpoint, query) :\n      this.endpointFetcher.fetchBindings(endpoint, query);\n    let totalItems = 0;\n    const stream = wrap<any>(inputStream, { autoStart: false, maxBufferSize: Infinity })\n      .map(rawData => {\n        totalItems++;\n        return quads ? rawData : Bindings(rawData);\n      });\n    inputStream.then(\n      subStream => subStream.on('end', () => stream.emit('metadata', { totalItems })),\n      () => {\n        // Do nothing\n      },\n    );\n\n    const metadata: () => Promise<Record<string, any>> = ActorQueryOperationSparqlEndpoint.cachifyMetadata(\n      () => new Promise((resolve, reject) => {\n        (<any> stream)._fillBuffer();\n        stream.on('error', reject);\n        stream.on('end', () => reject(new Error('No metadata was found')));\n        stream.on('metadata', resolve);\n      }),\n    );\n\n    if (quads) {\n      return <IActorQueryOperationOutputQuads> {\n        type: 'quads',\n        quadStream: stream,\n        metadata,\n      };\n    }\n    return <IActorQueryOperationOutputBindings> {\n      type: 'bindings',\n      bindingsStream: stream,\n      metadata,\n      variables: (<RDF.Variable[]> variables).map(x => termToString(x)),\n      canContainUndefs: true,\n    };\n  }\n}\n\nexport interface IActorQueryOperationSparqlEndpointArgs\n  extends IActorArgs<IActionQueryOperation, IActorTest, IActorQueryOperationOutput> {\n  mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n}\n"]}