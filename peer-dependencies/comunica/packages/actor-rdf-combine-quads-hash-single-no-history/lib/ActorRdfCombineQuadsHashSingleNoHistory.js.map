{"version":3,"file":"ActorRdfCombineQuadsHashSingleNoHistory.js","sourceRoot":"","sources":["ActorRdfCombineQuadsHashSingleNoHistory.ts"],"names":[],"mappings":";;;AAEA,2EAAuE;AAEvE,iDAA6D;AAC7D,qCAA+B;AAE/B,2CAA8C;AAE9C;;GAEG;AACH,MAAa,uCAAwC,SAAQ,4CAAoB;IAC/E,YAAmB,IAAiF;QAClG,KAAK,CAAC,IAAI,CAAC,CAAC;QAGJ,oBAAe,GAAG,KAAK,CAAC;QACxB,qBAAgB,GAAG,IAAI,CAAC;QACxB,uBAAkB,GAAG,IAAI,CAAC;QAC1B,oBAAe,GAAG,CAAC,CAAC;QACpB,oBAAe,GAAG,QAAQ,CAAC;QAC3B,oBAAe,GAAG,CAAC,CAAC;QACpB,oBAAe,GAAG,QAAQ,CAAC;IARrC,CAAC;IAUD;;;;OAIG;IACI,MAAM,CAAC,IAAI,CAAC,IAAc;QAC/B,OAAO,cAAI,EAAE;aACV,MAAM,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,6BAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;aACvD,MAAM,CAAC,KAAK,CAAC,CAAC;IACnB,CAAC;IAED;;;;;;OAMG;IACI,KAAK,CAAC,aAAa,CAAC,OAAe,EAAE,OAAe;QACzD,OAAO,OAAO,GAAG,OAAO,CAAC;IAC3B,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,KAAiB,EAAE,OAA4B;QACpE,MAAM,MAAM,GAA4B,EAAE,CAAC;QAC3C,MAAM,MAAM,GAA4B,IAAI,6BAAa,CAAC,CAAE,GAAG,OAAO,CAAC,OAAO,EAAE,EAAE,EAAE,UAAU,EAAE,KAAK,EAAE,IAAI,EAAE,QAAQ,EAAC,CAAE,CAAC;aACxH,SAAS,CAAC;YACT,SAAS,EAAE,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE;gBAC9B,IAAI,IAAI,CAAC,IAAI,KAAK,QAAQ,EAAE;oBAC1B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;wBAC7B,MAAM,IAAI,GAAG,uCAAuC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;wBAChE,IAAI,CAAC,CAAC,IAAI,IAAI,MAAM,CAAC,EAAE;4BACrB,IAAI,CAAC,IAAI,CAAC,CAAC;4BACX,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;yBACrB;wBAAA,CAAC;oBACJ,CAAC,CAAC,CAAA;iBACH;qBAAM;oBACL,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;wBAC7B,MAAM,CAAC,uCAAuC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;oBACpE,CAAC,CAAC,CAAA;iBACH;gBACD,IAAI,EAAE,CAAC;YACT,CAAC;SACF,CAAC,CAAA;QACF,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC;IAC3B,CAAC;CACF;AA1DD,0FA0DC","sourcesContent":["import type { QuadStream } from '@comunica/bus-query-operation';\nimport type { IActionRdfCombineQuads, IActorRdfCombineQuadsOutput, IQuadStreamUpdate } from '@comunica/bus-rdf-combine-quads';\nimport { ActorRdfCombineQuads } from '@comunica/bus-rdf-combine-quads';\nimport type { IActorArgs, IActorTest } from '@comunica/core';\nimport { AsyncIterator, ArrayIterator } from 'asynciterator';\nimport { sha1 } from 'hash.js';\nimport type * as RDF from 'rdf-js';\nimport { quadToStringQuad } from 'rdf-string';\n\n/**\n * A comunica Combine quads using hashes, does not maintain history RDF Combine Quads Actor.\n */\nexport class ActorRdfCombineQuadsHashSingleNoHistory extends ActorRdfCombineQuads {\n  public constructor(args: IActorArgs<IActionRdfCombineQuads, IActorTest, IActorRdfCombineQuadsOutput>) {\n    super(args);\n  }\n\n  protected canTrackChanges = false;\n  protected canMaintainOrder = true;\n  protected canAvoidDuplicates = true;\n  protected limitInsertsMin = 0;\n  protected limitInsertsMax = Infinity;\n  protected limitDeletesMin = 0;\n  protected limitDeletesMax = Infinity;\n\n  /**\n   * Create a string-based hash of the given object.\n   * @param quad The quad to hash\n   * @return {string} The object's hash.\n   */\n  public static hash(quad: RDF.Quad): string {\n    return sha1()\n      .update(require('canonicalize')(quadToStringQuad(quad)))\n      .digest('hex');\n  }\n\n  /**\n   * Gets the number of 'iterations' over streams required to complete\n   * this operation.\n   * @param inserts The number of insert operations\n   * @param deletes The number of delete operations\n   * @param hasBase Whether there is a base quad stream\n   */\n  public async getIterations(inserts: number, deletes: number): Promise<number> {\n    return inserts + deletes;\n  }\n\n  public async getOutput(quads: QuadStream, updates: IQuadStreamUpdate[]): Promise<IActorRdfCombineQuadsOutput> {\n    const hashes: Record<string, boolean> = {};\n    const result: AsyncIterator<RDF.Quad> = new ArrayIterator([ ...updates.reverse(), { quadStream: quads, type: 'insert'} ])\n    .transform({\n      transform: (item, done, push) => {\n        if (item.type === 'insert') {\n          item.quadStream.forEach(quad => {\n            const hash = ActorRdfCombineQuadsHashSingleNoHistory.hash(quad);\n            if (!(hash in hashes)) {\n              push(quad);\n              hashes[hash] = true;\n            };\n          })\n        } else {\n          item.quadStream.forEach(quad => {\n            hashes[ActorRdfCombineQuadsHashSingleNoHistory.hash(quad)] = true;\n          })\n        }\n        done();\n      }\n    })\n    return { quads: result };\n  }\n}\n"]}