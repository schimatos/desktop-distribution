{"version":3,"file":"ActorRdfDereferenceHttpParseBase.js","sourceRoot":"","sources":["ActorRdfDereferenceHttpParseBase.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionHttp, IActorHttpOutput } from '@comunica/bus-http';\nimport { ActorHttp } from '@comunica/bus-http';\nimport type { IActionRdfDereference,\n  IActorRdfDereferenceMediaMappingsArgs,\n  IActorRdfDereferenceOutput } from '@comunica/bus-rdf-dereference';\nimport {\n  ActorRdfDereferenceMediaMappings,\n} from '@comunica/bus-rdf-dereference';\nimport type {\n  IActionHandleRdfParse,\n  IActionMediaTypesRdfParse,\n  IActionRdfParse,\n  IActorOutputHandleRdfParse,\n  IActorOutputMediaTypesRdfParse,\n  IActorRdfParseOutput,\n  IActorTestHandleRdfParse,\n  IActorTestMediaTypesRdfParse,\n} from '@comunica/bus-rdf-parse';\nimport type { Actor, IActorTest, Mediator } from '@comunica/core';\nimport { Headers } from 'cross-fetch';\nimport { resolve as resolveRelative } from 'relative-to-absolute-iri';\n\n/**\n * An actor that listens on the 'rdf-dereference' bus.\n *\n * It starts by grabbing all available RDF media types from the RDF parse bus.\n * After that, it resolves the URL using the HTTP bus using an accept header compiled from the available media types.\n * Finally, the response is parsed using the RDF parse bus.\n */\nexport abstract class ActorRdfDereferenceHttpParseBase extends ActorRdfDereferenceMediaMappings\n  implements IActorRdfDereferenceHttpParseArgs {\n  public static readonly REGEX_MEDIATYPE: RegExp = /^[^ ;]*/u;\n\n  public readonly mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n\n  public readonly mediatorRdfParseMediatypes: Mediator<\n  Actor<IActionMediaTypesRdfParse, IActorTestMediaTypesRdfParse, IActorOutputMediaTypesRdfParse>,\n  IActionMediaTypesRdfParse, IActorTestMediaTypesRdfParse, IActorOutputMediaTypesRdfParse>;\n\n  public readonly mediatorRdfParseHandle: Mediator<\n  Actor<IActionHandleRdfParse, IActorTestHandleRdfParse, IActorOutputHandleRdfParse>,\n  IActionHandleRdfParse, IActorTestHandleRdfParse, IActorOutputHandleRdfParse>;\n\n  public readonly maxAcceptHeaderLength: number;\n  public readonly maxAcceptHeaderLengthBrowser: number;\n\n  public constructor(args: IActorRdfDereferenceHttpParseArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionRdfDereference): Promise<IActorTest> {\n    if (!/^https?:/u.test(action.url)) {\n      throw new Error(`Cannot retrieve ${action.url} because it is not an HTTP(S) URL.`);\n    }\n    return true;\n  }\n\n  public async run(action: IActionRdfDereference): Promise<IActorRdfDereferenceOutput> {\n    // Define accept header based on available media types.\n    const { mediaTypes } = await this.mediatorRdfParseMediatypes.mediate(\n      { context: action.context, mediaTypes: true },\n    );\n    const acceptHeader: string = this.mediaTypesToAcceptString(mediaTypes, this.getMaxAcceptHeaderLength());\n\n    // Resolve HTTP URL using appropriate accept header\n    const headers: Headers = new Headers({ Accept: acceptHeader });\n\n    // Append any custom passed headers\n    for (const key in action.headers) {\n      headers.append(key, action.headers[key]);\n    }\n\n    const httpAction: IActionHttp = {\n      context: action.context,\n      init: { headers, method: action.method },\n      input: action.url,\n    };\n    let httpResponse: IActorHttpOutput;\n    try {\n      httpResponse = await this.mediatorHttp.mediate(httpAction);\n    } catch (error: unknown) {\n      return this.handleDereferenceError(action, error);\n    }\n    // The response URL can be relative to the given URL\n    const url = resolveRelative(httpResponse.url, action.url);\n\n    // Convert output headers to a hash\n    const outputHeaders: Record<string, string> = {};\n    // eslint-disable-next-line no-return-assign\n    httpResponse.headers.forEach((value, key) => outputHeaders[key] = value);\n\n    // Only parse if retrieval was successful\n    if (httpResponse.status !== 200) {\n      const error = new Error(`Could not retrieve ${action.url} (${httpResponse.status}: ${\n        httpResponse.statusText || 'unknown error'})`);\n      // Close the body if we have one, to avoid process to hang\n      if (httpResponse.body) {\n        await httpResponse.body.cancel();\n      }\n      return this.handleDereferenceError(action, error);\n    }\n\n    // Wrap WhatWG readable stream into a Node.js readable stream\n    // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n    const responseStream: NodeJS.ReadableStream = ActorHttp.toNodeReadable(httpResponse.body);\n\n    // Parse the resulting response\n    const match: RegExpExecArray = <RegExpExecArray> ActorRdfDereferenceHttpParseBase.REGEX_MEDIATYPE\n      .exec(httpResponse.headers.get('content-type') ?? '');\n    let mediaType: string | undefined = match[0];\n    // If no media type could be found, try to determine it via the file extension\n    if (!mediaType || mediaType === 'text/plain') {\n      mediaType = this.getMediaTypeFromExtension(httpResponse.url);\n    }\n\n    const parseAction: IActionRdfParse = {\n      baseIRI: url,\n      headers: httpResponse.headers,\n      input: responseStream,\n    };\n    let parseOutput: IActorRdfParseOutput;\n    try {\n      parseOutput = (await this.mediatorRdfParseHandle.mediate(\n        { context: action.context, handle: parseAction, handleMediaType: mediaType },\n      )).handle;\n    } catch (error: unknown) {\n      return this.handleDereferenceError(action, error);\n    }\n\n    const quads = this.handleDereferenceStreamErrors(action, parseOutput.quads);\n\n    // Return the parsed quad stream and whether or not only triples are supported\n    return { url, quads, triples: parseOutput.triples, headers: outputHeaders };\n  }\n\n  public mediaTypesToAcceptString(mediaTypes: Record<string, number>, maxLength: number): string {\n    const wildcard = '*/*;q=0.1';\n    const parts: string[] = [];\n    const sortedMediaTypes = Object.keys(mediaTypes)\n      .map(mediaType => ({ mediaType, priority: mediaTypes[mediaType] }))\n      .sort((left, right) => right.priority - left.priority);\n    // Take into account the ',' characters joining each type\n    const separatorLength = sortedMediaTypes.length - 1;\n    let partsLength = separatorLength;\n    for (const entry of sortedMediaTypes) {\n      const part = entry.mediaType + (entry.priority !== 1 ?\n        `;q=${entry.priority.toFixed(3).replace(/0*$/u, '')}` :\n        '');\n      if (partsLength + part.length > maxLength) {\n        while (partsLength + wildcard.length > maxLength) {\n          const last = parts.pop() || '';\n          // Don't forget the ','\n          partsLength -= last.length + 1;\n        }\n        parts.push(wildcard);\n        break;\n      }\n      parts.push(part);\n      partsLength += part.length;\n    }\n    if (parts.length === 0) {\n      return '*/*';\n    }\n    return parts.join(',');\n  }\n\n  protected abstract getMaxAcceptHeaderLength(): number;\n}\n\nexport interface IActorRdfDereferenceHttpParseArgs extends\n  IActorRdfDereferenceMediaMappingsArgs {\n  mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n  mediatorRdfParseMediatypes: Mediator<\n  Actor<IActionMediaTypesRdfParse, IActorTestMediaTypesRdfParse, IActorOutputMediaTypesRdfParse>,\n  IActionMediaTypesRdfParse, IActorTestMediaTypesRdfParse, IActorOutputMediaTypesRdfParse>;\n  mediatorRdfParseHandle: Mediator<\n  Actor<IActionHandleRdfParse, IActorTestHandleRdfParse, IActorOutputHandleRdfParse>,\n  IActionHandleRdfParse, IActorTestHandleRdfParse, IActorOutputHandleRdfParse>;\n  maxAcceptHeaderLength: number;\n  maxAcceptHeaderLengthBrowser: number;\n}\n"]}