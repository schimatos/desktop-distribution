{"version":3,"file":"PagedAsyncRdfIterator.js","sourceRoot":"","sources":["PagedAsyncRdfIterator.ts"],"names":[],"mappings":";;;AACA,iDAAiD;AAGjD;;GAEG;AACH,MAAsB,qBAAsB,SAAQ,gCAA0B;IAK5E,YAAmB,QAAgB,EAAE,OAAiC;QACpE,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QACd,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC1B,CAAC;IAEM,KAAK,CAAC,KAAa,EAAE,IAAgB;QAC1C,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC;iBAC1C,IAAI,CAAC,IAAI,CAAC;iBACV,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;SAC9C;aAAM;YACL,IAAI,EAAE,CAAC;SACR;IACH,CAAC;IAaD;;;;;OAKG;IACO,KAAK,CAAC,aAAa,CAAC,GAAW,EAAE,IAAY;QACrD,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC;QACzB,IAAI,KAAK,GAAG,KAAK,CAAC;QAClB,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,MAAM,EAAE,GAAe,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC,QAAiB,EAAE,EAAE;YAC7E,IAAI,QAAQ,EAAE;gBACZ,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC;gBACxB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;aACtB;iBAAM,IAAI,CAAC,KAAK,EAAE;gBACjB,WAAW,GAAG,IAAI,CAAC;aACpB;iBAAM;gBACL,IAAI,CAAC,KAAK,EAAE,CAAC;aACd;QACH,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAc,EAAE,EAAE;YAC/B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACjB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACvB,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;QAE5D,EAAE,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;YAChB,KAAK,GAAG,IAAI,CAAC;YACb,IAAI,WAAW,EAAE;gBACf,IAAI,CAAC,KAAK,EAAE,CAAC;aACd;QACH,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AApED,sDAoEC","sourcesContent":["import type { BufferedIteratorOptions } from 'asynciterator';\nimport { BufferedIterator } from 'asynciterator';\nimport type * as RDF from 'rdf-js';\n\n/**\n * An abstract quad iterator that iterates over several pages.\n */\nexport abstract class PagedAsyncRdfIterator extends BufferedIterator<RDF.Quad> implements RDF.Stream {\n  private readonly startUrl: string;\n  private nextUrl?: string;\n  private page: number;\n\n  public constructor(startUrl: string, options?: BufferedIteratorOptions) {\n    super(options);\n    this.page = 0;\n    this.startUrl = startUrl;\n    this.nextUrl = startUrl;\n  }\n\n  public _read(count: number, done: () => void): void {\n    if (this.nextUrl) {\n      this.startIterator(this.nextUrl, this.page++)\n        .then(done)\n        .catch(error => this.emit('error', error));\n    } else {\n      done();\n    }\n  }\n\n  /**\n   * Create a new iterator for the given url, with the given page id.\n   * @param {string} url The URL for which a quad iterator shuld be created.\n   * @param {number} page The numerical page id. The first page is always page 0.\n   * @param {(nextPage: string) => void} onNextPage A callback for when the next page url has been determined.\n   *                                                This may be falsy if the last page was found\n   * @return {Promise<RDF.Stream>} A promise that resolves to the quad data stream for the given page.\n   */\n  protected abstract getIterator(url: string, page: number, onNextPage: (nextPage?: string) => void):\n  Promise<RDF.Stream>;\n\n  /**\n   * Start an iterator for the given page and inherit all its data elements and error event.\n   * @param {string} url The URL for which a quad iterator should be created.\n   * @param {number} page The numerical page id. The first page is always page 0.\n   * @return {Promise<any>} A promise that resolves when a new iterator was started (but not necessarily ended).\n   */\n  protected async startIterator(url: string, page: number): Promise<any> {\n    this.nextUrl = undefined;\n    let ended = false;\n    let shouldClose = false;\n    const it: RDF.Stream = await this.getIterator(url, page, (nextPage?: string) => {\n      if (nextPage) {\n        this.nextUrl = nextPage;\n        this.readable = true;\n      } else if (!ended) {\n        shouldClose = true;\n      } else {\n        this.close();\n      }\n    });\n\n    it.on('data', (quad: RDF.Quad) => {\n      this._push(quad);\n      this.readable = true;\n    });\n\n    it.on('error', (error: Error) => this.emit('error', error));\n\n    it.on('end', () => {\n      ended = true;\n      if (shouldClose) {\n        this.close();\n      }\n    });\n  }\n}\n"]}