{"version":3,"file":"ActorRdfJoinHash.js","sourceRoot":"","sources":["ActorRdfJoinHash.ts"],"names":[],"mappings":";;;AAGA,uEAEuC;AAEvC,yDAAsD;AAGtD,yCAAqC;AAErC;;GAEG;AACH,MAAa,gBAAiB,SAAQ,2BAAY;IAChD,YAAmB,IAAqF;QACtG,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACjB,CAAC;IAED;;;;;;OAMG;IACO,MAAM,CAAC,IAAI,CAAC,QAAkB,EAAE,SAAmB;QAC3D,OAAO,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACpE,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,MAAsB;QAC3C,MAAM,SAAS,GAAG,2BAAY,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;QAC5D,MAAM,IAAI,GAAG,IAAI,oBAAQ,CACvB,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,cAAc,EAChC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,cAAc,EAChC,KAAK,CAAC,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC,EAC1C,2BAAY,CAAC,IAAI,CACxB,CAAC;QACF,OAAO;YACL,IAAI,EAAE,UAAU;YAChB,cAAc,EAAE,IAAI;YACpB,SAAS,EAAE,2BAAY,CAAC,aAAa,CAAC,MAAM,CAAC;YAC7C,gBAAgB,EAAE,KAAK;SACxB,CAAC;IACJ,CAAC;IAES,KAAK,CAAC,aAAa,CAAC,MAAsB;QAClD,qEAAqE;QACrE,OAAO,CAAC,MAAM,iCAAW,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,MAAM,iCAAW,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;IAC/G,CAAC;CACF;AApCD,4CAoCC","sourcesContent":["import type { Bindings,\n  IActorQueryOperationOutput,\n  IActorQueryOperationOutputBindings } from '@comunica/bus-query-operation';\nimport {\n  getMetadata,\n} from '@comunica/bus-query-operation';\nimport type { IActionRdfJoin } from '@comunica/bus-rdf-join';\nimport { ActorRdfJoin } from '@comunica/bus-rdf-join';\nimport type { IActorArgs } from '@comunica/core';\nimport type { IMediatorTypeIterations } from '@comunica/mediatortype-iterations';\nimport { HashJoin } from 'asyncjoin';\n\n/**\n * A comunica Hash RDF Join Actor.\n */\nexport class ActorRdfJoinHash extends ActorRdfJoin {\n  public constructor(args: IActorArgs<IActionRdfJoin, IMediatorTypeIterations, IActorQueryOperationOutput>) {\n    super(args, 2);\n  }\n\n  /**\n   * Creates a hash of the given bindings by concatenating the results of the given variables.\n   * This function will not sort the variables and expects them to be in the same order for every call.\n   * @param {Bindings} bindings\n   * @param {string[]} variables\n   * @returns {string}\n   */\n  protected static hash(bindings: Bindings, variables: string[]): string {\n    return variables.map(variable => bindings.get(variable)).join('');\n  }\n\n  public async getOutput(action: IActionRdfJoin): Promise<IActorQueryOperationOutputBindings> {\n    const variables = ActorRdfJoin.overlappingVariables(action);\n    const join = new HashJoin<Bindings, string, Bindings>(\n      action.entries[0].bindingsStream,\n      action.entries[1].bindingsStream,\n      entry => ActorRdfJoinHash.hash(entry, variables),\n      <any> ActorRdfJoin.join,\n    );\n    return {\n      type: 'bindings',\n      bindingsStream: join,\n      variables: ActorRdfJoin.joinVariables(action),\n      canContainUndefs: false,\n    };\n  }\n\n  protected async getIterations(action: IActionRdfJoin): Promise<number> {\n    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n    return (await getMetadata(action.entries[0])).totalItems + (await getMetadata(action.entries[1])).totalItems;\n  }\n}\n"]}