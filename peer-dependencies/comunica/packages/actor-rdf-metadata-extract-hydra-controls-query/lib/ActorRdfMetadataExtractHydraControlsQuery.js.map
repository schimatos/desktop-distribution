{"version":3,"file":"ActorRdfMetadataExtractHydraControlsQuery.js","sourceRoot":"","sources":["ActorRdfMetadataExtractHydraControlsQuery.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA,iFAAkF;AAIlF,6CAAwD;AACxD,kEAAoD;AAEpD;;GAEG;AACH,MAAa,yCAA0C,SAAQ,uDAA4B;IAiBzF,YAAmB,IAAuC;QACxD,KAAK,CAAC,iBAAiB,EAAE,yCAAyC,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;QAHzE,2BAAsB,GAAgC,EAAE,CAAC;IAI5E,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAAiC;QACjD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAiC;QAChD,OAAO;YACL,QAAQ,EAAE;gBACR,WAAW,EAAE,IAAI,CAAC,sBAAsB,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE,UAAU,EAAE,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;aAC5G;SACF,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACI,sBAAsB,CAAC,QAAgB;QAC5C,MAAM,iBAAiB,GAAgB,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;QAC7E,IAAI,iBAAiB,EAAE;YACrB,OAAO,iBAAiB,CAAC;SAC1B;QACD,4CAA4C;QAC5C,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,GAAG,mBAAgB,CAAC,QAAQ,CAAC,CAAC;IAC5E,CAAC;IAED;;;;OAIG;IACI,sBAAsB,CAAC,YAAiB;QAC7C,MAAM,OAAO,GAAW,YAAY,CAAC,EAAE,CAAC;QACxC,MAAM,MAAM,GAAkB,EAAE,CAAC;QACjC,IAAI,YAAY,CAAC,MAAM,EAAE;YACvB,KAAK,MAAM,MAAM,IAAI,YAAY,CAAC,MAAM,EAAE;gBACxC,MAAM,cAAc,GAAgB,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBACjF,MAAM,QAAQ,GAAG,CAAC,MAAM,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,KAAU,EAAE,EAAE;oBACtE,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC;oBACrC,OAAO,GAAG,CAAC;gBACb,CAAC,EAAE,EAAE,CAAC,CAAC;gBACP,MAAM,MAAM,GAAG,CAAC,OAA+B,EAAU,EAAE,CAAC,cAAc;qBACvE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,SAAiC,EAAE,GAAG,EAAE,EAAE;oBAC7E,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;oBACxC,OAAO,SAAS,CAAC;gBACnB,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;gBACV,MAAM,CAAC,IAAI,CAAC;oBACV,OAAO;oBACP,MAAM;oBACN,QAAQ;oBACR,QAAQ,EAAE,MAAM,CAAC,QAAQ;iBAC1B,CAAC,CAAC;aACJ;SACF;QAED,OAAO,EAAE,MAAM,EAAE,CAAC;IACpB,CAAC;;AA7EH,8FA8EC;AA7EwB,yDAAe,GAAW;;;;;;;;;;;;MAY7C,CAAC","sourcesContent":["import type { IActionRdfMetadataExtract, IActorRdfMetadataExtractOutput,\n  IActorRdfMetadataExtractQueryArgs } from '@comunica/bus-rdf-metadata-extract';\nimport { ActorRdfMetadataExtractQuery } from '@comunica/bus-rdf-metadata-extract';\nimport type { IActorTest } from '@comunica/core';\n\nimport type { UriTemplate } from 'uritemplate';\nimport { parse as parseUriTemplate } from 'uritemplate';\nimport * as GRAPHQLLD_CONTEXT from './context.json';\n\n/**\n * An RDF Metadata Extract Actor that extracts all Hydra search forms from the metadata stream.\n */\nexport class ActorRdfMetadataExtractHydraControlsQuery extends ActorRdfMetadataExtractQuery {\n  public static readonly GRAPHQLLD_QUERY: string = `\n    query($pageUrl: String) @single(scope: all) {\n      id\n      graph\n      subset(_: $pageUrl)\n      search @plural {\n        template\n        mapping @optional @plural {\n          variable\n          property\n        }\n      }\n    }`;\n\n  protected readonly parsedUriTemplateCache: Record<string, UriTemplate> = {};\n\n  public constructor(args: IActorRdfMetadataExtractQueryArgs) {\n    super(GRAPHQLLD_CONTEXT, ActorRdfMetadataExtractHydraControlsQuery.GRAPHQLLD_QUERY, args);\n  }\n\n  public async test(action: IActionRdfMetadataExtract): Promise<IActorTest> {\n    return true;\n  }\n\n  public async run(action: IActionRdfMetadataExtract): Promise<IActorRdfMetadataExtractOutput> {\n    return {\n      metadata: {\n        searchForms: this.constructHydraControls(await this.queryData(action.metadata, { '?pageUrl': action.url })),\n      },\n    };\n  }\n\n  /**\n   * Parse a URI template, or retrieve it from a cache.\n   * @param {string} template A URI template string.\n   * @return {} A parsed URI template object.\n   */\n  public parseUriTemplateCached(template: string): UriTemplate {\n    const cachedUriTemplate: UriTemplate = this.parsedUriTemplateCache[template];\n    if (cachedUriTemplate) {\n      return cachedUriTemplate;\n    }\n    // eslint-disable-next-line no-return-assign\n    return this.parsedUriTemplateCache[template] = parseUriTemplate(template);\n  }\n\n  /**\n   * Find all hydra controls within the given query results.\n   * @param queryResults The query results.\n   * @return The discovered Hydra search forms.\n   */\n  public constructHydraControls(queryResults: any): ISearchForms {\n    const dataset: string = queryResults.id;\n    const values: ISearchForm[] = [];\n    if (queryResults.search) {\n      for (const search of queryResults.search) {\n        const searchTemplate: UriTemplate = this.parseUriTemplateCached(search.template);\n        const mappings = (search.mapping || []).reduce((acc: any, entry: any) => {\n          acc[entry.property] = entry.variable;\n          return acc;\n        }, {});\n        const getUri = (entries: Record<string, string>): string => searchTemplate\n          .expand(Object.keys(entries).reduce((variables: Record<string, string>, key) => {\n            variables[mappings[key]] = entries[key];\n            return variables;\n          }, {}));\n        values.push({\n          dataset,\n          getUri,\n          mappings,\n          template: search.template,\n        });\n      }\n    }\n\n    return { values };\n  }\n}\n\nexport interface ISearchForm {\n  /**\n   * The dataset in which the search form is defined.\n   */\n  dataset: string;\n  /**\n   * The URI template containing Hydra variables.\n   */\n  template: string;\n  /**\n   * The mappings.\n   * With as keys the Hydra properties,\n   * and as values the Hydra variables\n   */\n  mappings: Record<string, string>;\n\n  /**\n   * Instantiate a uri based on the given Hydra variable values.\n   * @param entries Entries with as keys Hydra properties,\n   *                and as values Hydra variable values.\n   * @return {string} The instantiated URI\n   */\n  getUri: (entries: Record<string, string>) => string;\n}\n\nexport interface ISearchForms {\n  /**\n   * All available search forms.\n   */\n  values: ISearchForm[];\n  // TODO: in the future, a query-based search form getter should be available here.\n}\n"]}