{"version":3,"file":"FederatedQuadSource.js","sourceRoot":"","sources":["FederatedQuadSource.ts"],"names":[],"mappings":";;;AAEA,yFAC4F;AAE5F,yDAAyD;AAEzD,iDAAgF;AAChF,uDAA+C;AAE/C,yCAAqC;AAErC,qDAA0C;AAE1C,MAAM,EAAE,GAAG,IAAI,8BAAW,EAAE,CAAC;AAE7B;;;GAGG;AACH,MAAa,mBAAmB;IAa9B,YAAmB,0BAC6F,EAChH,OAAsB,EAAE,aAA2C,EACnE,iBAA0B;QACxB,IAAI,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;QAC7D,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,kDAAmB,CAAC,CAAC;QAChD,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,MAAM,CAAC,kDAAmB,CAAC,CAAC;QAC1D,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,cAAc,GAAG,IAAI,yBAAO,EAAE,CAAC;QAEpC,wDAAwD;QACxD,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;gBACjC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;oBACnC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;iBACpC;aACF;SACF;IACH,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,WAAW,CAAC,IAAc;QACtC,OAAO,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC;IACtC,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,cAAc,CAAC,KAAmB,EAAE,MAAoB;QACpE,OAAO,CAAC,CAAC,mBAAmB,CAAC,WAAW,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YAC/F,CAAC,CAAC,mBAAmB,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAChG,CAAC,CAAC,mBAAmB,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YACvF,CAAC,CAAC,mBAAmB,CAAC,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;IACzF,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,aAAa,CAAC,IAAc,EAAE,QAAgB;QAC1D,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE;YACjC,OAAO,IAAI,8BAAe,CAAC,MAAM,QAAQ,IAAI,IAAI,CAAC,KAAK,EAAE,EACvD,EAAE,CAAC,SAAS,CAAC,GAAG,mBAAmB,CAAC,aAAa,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;SAClF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,aAAa,CAAoC,IAAO,EAAE,QAAgB;QACtF,OAAO,oBAAQ,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,mBAAmB,CAAC,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;IACnF,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,eAAe,CAAC,IAAc,EAAE,QAAgB;QAC5D,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,IAAI,YAAY,IAAI,IAAI,EAAE;YACzD,IAAI,GAAsB,IAAK,CAAC,UAAU,CAAC;SAC5C;QACD,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE;YACjC,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,mBAAmB,CAAC,aAAa,CAAC,EAAE;gBAC5D,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,mBAAmB,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;gBACzF,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,mBAAmB,CAAC,aAAa,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;gBAChG,2BAA2B;gBAC3B,IAAI,YAAY,KAAK,QAAQ,EAAE;oBAC7B,kCAAkC;oBAClC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,cAAc,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;oBAC1E,OAAO,EAAE,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;iBAChC;gBACD,kCAAkC;gBAClC,OAAO,IAAI,CAAC;aACb;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;;;;;;OAWG;IACI,aAAa,CAAC,MAAmB,EAAE,OAAqB;QAC7D,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC3B,OAAO,KAAK,CAAC;SACd;QACD,MAAM,aAAa,GAA+B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACjF,IAAI,aAAa,EAAE;YACjB,KAAK,MAAM,YAAY,IAAI,aAAa,EAAE;gBACxC,IAAI,mBAAmB,CAAC,cAAc,CAAC,OAAO,EAAE,YAAY,CAAC,EAAE;oBAC7D,OAAO,IAAI,CAAC;iBACb;aACF;SACF;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;OAIG;IACI,WAAW,CAAC,MAAmB;QACpC,IAAI,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAC1C,IAAI,QAAQ,KAAK,SAAS,EAAE;YAC1B,QAAQ,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;YACpC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;SACtC;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEM,KAAK,CAAC,OAAiB,EAAE,SAAmB,EAAE,MAAgB,EAAE,KAAe;QACpF,4BAA4B;QAC5B,MAAM,QAAQ,GAAwB,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC;QACxD,IAAI,gBAAgB,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;QAE3C,wDAAwD;QACxD,MAAM,iBAAiB,GAAG,CAAC,iBAAyB,EAAE,MAAmB,EACvE,OAAiC,EAAE,YAAkC,EAAQ,EAAE;YAC/E,IAAI,IAAI,CAAC,iBAAiB,IAAI,CAAC,iBAAiB,EAAE;gBAChD,uEAAuE;gBACvE,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE;oBACjC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBACjE;aACF;YACD,IAAI,CAAC,gBAAgB,EAAE;gBACrB,IAAI,YAAY,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;oBAC7C,sDAAsD;oBACtD,EAAE,CAAC,WAAW,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;iBAC1C;qBAAM;oBACL,EAAE,CAAC,WAAW,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;iBACtC;aACF;QACH,CAAC,CAAC;QAEF,MAAM,OAAO,GAAuC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAC,MAAM,EAAC,EAAE;YAC9F,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YAE1C,yEAAyE;YACzE,8GAA8G;YAC9G,MAAM,QAAQ,GAAG,mBAAmB,CAAC,eAAe,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;YACxE,MAAM,QAAQ,GAAG,mBAAmB,CAAC,eAAe,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;YAC1E,MAAM,QAAQ,GAAG,mBAAmB,CAAC,eAAe,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;YACvE,MAAM,QAAQ,GAAG,mBAAmB,CAAC,eAAe,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;YACtE,IAAI,OAAoC,CAAC;YAEzC,+CAA+C;YAC/C,IAAI,OAAO,GAAkB,mDAAoB,CAAC,MAAM,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;YAC/E,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,iDAAkB,EACtC,EAAE,IAAI,EAAE,gDAAiB,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,iDAAkB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAE1E,IAAI,MAAyC,CAAC;YAC9C,wEAAwE;YACxE,0FAA0F;YAC1F,4BAA4B;YAC5B,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ;gBAClD,0CAA0C;gBAC1C,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,OAAO,GAAG,IAAI,CAAC,cAAc;qBACrD,aAAa,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC,EAAE;gBAC3D,MAAM,GAAG,EAAE,IAAI,EAAE,IAAI,6BAAa,CAAC,EAAE,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC;gBAC/D,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC;aACxD;iBAAM;gBACL,MAAM,GAAG,MAAM,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,CAAC;aAC9E;YAED,uCAAuC;YACvC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,WAAgC,EAAE,EAAE;gBACvE,IAAI,CAAC,CAAC,WAAW,CAAC,UAAU,IAAI,WAAW,CAAC,UAAU,KAAK,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,UAAU,CAAC,EAAE;oBACzG,0DAA0D;oBAC1D,QAAQ,CAAC,UAAU,GAAG,QAAQ,CAAC;oBAC/B,gBAAgB,GAAG,CAAC,CAAC;oBACrB,iBAAiB,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;iBAC3D;qBAAM;oBACL,QAAQ,CAAC,UAAU,IAAI,WAAW,CAAC,UAAU,CAAC;oBAC9C,gBAAgB,EAAE,CAAC;oBACnB,iBAAiB,CAAC,WAAW,CAAC,UAAU,EAAE,MAAM,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;iBACzE;YACH,CAAC,CAAC,CAAC;YAEH,6CAA6C;YAC7C,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,mBAAmB,CAAC,aAAa,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;YACtF,4GAA4G;YAC5G,IAAI,KAAK,CAAC,QAAQ,KAAK,UAAU,EAAE;gBACjC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,KAAK,cAAc,CAAC,CAAC;aACpE;YAED,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC,CAAC;QAEJ,uCAAuC;QACvC,MAAM,EAAE,GAAG,IAAI,iCAAiB,CAAC,KAAK,IAAG,EAAE,CAAC,IAAI,6BAAa,CAAC,MAAM,OAAO,CAAC,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;QAEpG,kDAAkD;QAClD,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,EAAE,CAAC,WAAW,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;SACtC;QAED,OAAO,EAAE,CAAC;IACZ,CAAC;;AAjPH,kDAkPC;AAjPyB,iCAAa,GAAG,6BAA6B,CAAC","sourcesContent":["import type { DataSources, IActionRdfResolveQuadPattern,\n  IActorRdfResolveQuadPatternOutput, IDataSource, IQuadSource } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport { getDataSourceType, getDataSourceValue, KEY_CONTEXT_SOURCE,\n  KEY_CONTEXT_SOURCES, getDataSourceContext } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport type { ActionContext, Actor, IActorTest, Mediator } from '@comunica/core';\nimport { BlankNodeScoped } from '@comunica/data-factory';\nimport type { AsyncIterator } from 'asynciterator';\nimport { ArrayIterator, TransformIterator, UnionIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport type * as RDF from 'rdf-js';\nimport { mapTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\n\nconst DF = new DataFactory();\n\n/**\n * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.\n * It will call the given mediator to evaluate each quad pattern query separately.\n */\nexport class FederatedQuadSource implements IQuadSource {\n  private static readonly SKOLEM_PREFIX = 'urn:comunica_skolem:source_';\n\n  protected readonly mediatorResolveQuadPattern: Mediator<Actor<IActionRdfResolveQuadPattern, IActorTest,\n  IActorRdfResolveQuadPatternOutput>, IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput>;\n\n  protected readonly sources: DataSources;\n  protected readonly contextDefault: ActionContext;\n  protected readonly emptyPatterns: Map<IDataSource, RDF.BaseQuad[]>;\n  protected readonly sourceIds: Map<IDataSource, string>;\n  protected readonly skipEmptyPatterns: boolean;\n  protected readonly algebraFactory: Factory;\n\n  public constructor(mediatorResolveQuadPattern: Mediator<Actor<IActionRdfResolveQuadPattern, IActorTest,\n  IActorRdfResolveQuadPatternOutput>, IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput>,\n  context: ActionContext, emptyPatterns: Map<IDataSource, RDF.Quad[]>,\n  skipEmptyPatterns: boolean) {\n    this.mediatorResolveQuadPattern = mediatorResolveQuadPattern;\n    this.sources = context.get(KEY_CONTEXT_SOURCES);\n    this.contextDefault = context.delete(KEY_CONTEXT_SOURCES);\n    this.emptyPatterns = emptyPatterns;\n    this.sourceIds = new Map();\n    this.skipEmptyPatterns = skipEmptyPatterns;\n    this.algebraFactory = new Factory();\n\n    // Initialize sources in the emptyPatterns datastructure\n    if (this.skipEmptyPatterns) {\n      for (const source of this.sources) {\n        if (!this.emptyPatterns.has(source)) {\n          this.emptyPatterns.set(source, []);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the given RDF term is not bound to an exact value.\n   * I.e., if it is not a Variable.\n   * @param {RDF.Term} term An RDF term.\n   * @return {boolean} If it is not bound.\n   */\n  public static isTermBound(term: RDF.Term): boolean {\n    return term.termType !== 'Variable';\n  }\n\n  /**\n   * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.\n   * This will also return true if the patterns are equal.\n   * @param {RDF.BaseQuad} child A child pattern.\n   * @param {RDF.BaseQuad} parent A parent pattern.\n   * @return {boolean} If child is a sub-pattern of parent\n   */\n  public static isSubPatternOf(child: RDF.BaseQuad, parent: RDF.BaseQuad): boolean {\n    return (!FederatedQuadSource.isTermBound(parent.subject) || parent.subject.equals(child.subject)) &&\n      (!FederatedQuadSource.isTermBound(parent.predicate) || parent.predicate.equals(child.predicate)) &&\n      (!FederatedQuadSource.isTermBound(parent.object) || parent.object.equals(child.object)) &&\n      (!FederatedQuadSource.isTermBound(parent.graph) || parent.graph.equals(child.graph));\n  }\n\n  /**\n   * If the given term is a blank node, return a deterministic named node for it\n   * based on the source id and the blank node value.\n   * @param term Any RDF term.\n   * @param sourceId A source identifier.\n   * @return If the given term was a blank node, this will return a skolemized named node, otherwise the original term.\n   */\n  public static skolemizeTerm(term: RDF.Term, sourceId: string): RDF.Term | BlankNodeScoped {\n    if (term.termType === 'BlankNode') {\n      return new BlankNodeScoped(`bc_${sourceId}_${term.value}`,\n        DF.namedNode(`${FederatedQuadSource.SKOLEM_PREFIX}${sourceId}:${term.value}`));\n    }\n    return term;\n  }\n\n  /**\n   * Skolemize all terms in the given quad.\n   * @param quad An RDF quad.\n   * @param sourceId A source identifier.\n   * @return The skolemized quad.\n   */\n  public static skolemizeQuad<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, sourceId: string): Q {\n    return mapTerms(quad, term => FederatedQuadSource.skolemizeTerm(term, sourceId));\n  }\n\n  /**\n   * If a given term was a skolemized named node for the given source id,\n   * deskolemize it again to a blank node.\n   * If the given term was a skolemized named node for another source, return false.\n   * If the given term was not a skolemized named node, return the original term.\n   * @param term Any RDF term.\n   * @param sourceId A source identifier.\n   */\n  public static deskolemizeTerm(term: RDF.Term, sourceId: string): RDF.Term | null {\n    if (term.termType === 'BlankNode' && 'skolemized' in term) {\n      term = (<BlankNodeScoped> term).skolemized;\n    }\n    if (term.termType === 'NamedNode') {\n      if (term.value.startsWith(FederatedQuadSource.SKOLEM_PREFIX)) {\n        const colonSeparator = term.value.indexOf(':', FederatedQuadSource.SKOLEM_PREFIX.length);\n        const termSourceId = term.value.slice(FederatedQuadSource.SKOLEM_PREFIX.length, colonSeparator);\n        // We had a skolemized term\n        if (termSourceId === sourceId) {\n          // It came from the correct source\n          const termLabel = term.value.slice(colonSeparator + 1, term.value.length);\n          return DF.blankNode(termLabel);\n        }\n        // It came from a different source\n        return null;\n      }\n    }\n    return term;\n  }\n\n  /**\n   * If the given source is guaranteed to produce an empty result for the given pattern.\n   *\n   * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.\n   * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.\n   * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.\n   * This is under the assumption that sources will remain static during query evaluation.\n   *\n   * @param {IQuerySource} source\n   * @param {RDF.BaseQuad} pattern\n   * @return {boolean}\n   */\n  public isSourceEmpty(source: IDataSource, pattern: RDF.BaseQuad): boolean {\n    if (!this.skipEmptyPatterns) {\n      return false;\n    }\n    const emptyPatterns: RDF.BaseQuad[] | undefined = this.emptyPatterns.get(source);\n    if (emptyPatterns) {\n      for (const emptyPattern of emptyPatterns) {\n        if (FederatedQuadSource.isSubPatternOf(pattern, emptyPattern)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the unique, deterministic id for the given source.\n   * @param source A data source.\n   * @return The id of the given source.\n   */\n  public getSourceId(source: IDataSource): string {\n    let sourceId = this.sourceIds.get(source);\n    if (sourceId === undefined) {\n      sourceId = `${this.sourceIds.size}`;\n      this.sourceIds.set(source, sourceId);\n    }\n    return sourceId;\n  }\n\n  public match(subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term): AsyncIterator<RDF.Quad> {\n    // Counters for our metadata\n    const metadata: Record<string, any> = { totalItems: 0 };\n    let remainingSources = this.sources.length;\n\n    // Anonymous function to handle totalItems from metadata\n    const checkEmitMetadata = (currentTotalItems: number, source: IDataSource,\n      pattern: RDF.BaseQuad | undefined, lastMetadata?: Record<string, any>): void => {\n      if (this.skipEmptyPatterns && !currentTotalItems) {\n        // Because another call may have added more information in the meantime\n        if (pattern && !this.isSourceEmpty(source, pattern)) {\n          (<RDF.BaseQuad[]> this.emptyPatterns.get(source)).push(pattern);\n        }\n      }\n      if (!remainingSources) {\n        if (lastMetadata && this.sources.length === 1) {\n          // If we only had one source, emit the metadata as-is.\n          it.setProperty('metadata', lastMetadata);\n        } else {\n          it.setProperty('metadata', metadata);\n        }\n      }\n    };\n\n    const proxyIt: Promise<AsyncIterator<RDF.Quad>[]> = Promise.all(this.sources.map(async source => {\n      const sourceId = this.getSourceId(source);\n\n      // Deskolemize terms, so we send the original blank nodes to each source.\n      // Note that some sources may not match bnodes by label. SPARQL endpoints for example consider them variables.\n      const patternS = FederatedQuadSource.deskolemizeTerm(subject, sourceId);\n      const patternP = FederatedQuadSource.deskolemizeTerm(predicate, sourceId);\n      const patternO = FederatedQuadSource.deskolemizeTerm(object, sourceId);\n      const patternG = FederatedQuadSource.deskolemizeTerm(graph, sourceId);\n      let pattern: Algebra.Pattern | undefined;\n\n      // Prepare the context for this specific source\n      let context: ActionContext = getDataSourceContext(source, this.contextDefault);\n      context = context.set(KEY_CONTEXT_SOURCE,\n        { type: getDataSourceType(source), value: getDataSourceValue(source) });\n\n      let output: IActorRdfResolveQuadPatternOutput;\n      // If any of the deskolemized blank nodes originate from another source,\n      // or if we can predict that the given source will have no bindings for the given pattern,\n      // return an empty iterator.\n      if (!patternS || !patternP || !patternO || !patternG ||\n        // eslint-disable-next-line no-cond-assign\n        this.isSourceEmpty(source, pattern = this.algebraFactory\n          .createPattern(patternS, patternP, patternO, patternG))) {\n        output = { data: new ArrayIterator([], { autoStart: false }) };\n        output.data.setProperty('metadata', { totalItems: 0 });\n      } else {\n        output = await this.mediatorResolveQuadPattern.mediate({ pattern, context });\n      }\n\n      // Handle the metadata from this source\n      output.data.getProperty('metadata', (subMetadata: Record<string, any>) => {\n        if ((!subMetadata.totalItems && subMetadata.totalItems !== 0) || !Number.isFinite(subMetadata.totalItems)) {\n          // We're already at infinite, so ignore any later metadata\n          metadata.totalItems = Infinity;\n          remainingSources = 0;\n          checkEmitMetadata(Infinity, source, pattern, subMetadata);\n        } else {\n          metadata.totalItems += subMetadata.totalItems;\n          remainingSources--;\n          checkEmitMetadata(subMetadata.totalItems, source, pattern, subMetadata);\n        }\n      });\n\n      // Determine the data stream from this source\n      let data = output.data.map(quad => FederatedQuadSource.skolemizeQuad(quad, sourceId));\n      // SPARQL query semantics allow graph variables to only match with named graphs, excluding the default graph\n      if (graph.termType === 'Variable') {\n        data = data.filter(quad => quad.graph.termType !== 'DefaultGraph');\n      }\n\n      return data;\n    }));\n\n    // Take the union of all source streams\n    const it = new TransformIterator(async() => new UnionIterator(await proxyIt), { autoStart: false });\n\n    // If we have 0 sources, immediately emit metadata\n    if (this.sources.length === 0) {\n      it.setProperty('metadata', metadata);\n    }\n\n    return it;\n  }\n}\n"]}