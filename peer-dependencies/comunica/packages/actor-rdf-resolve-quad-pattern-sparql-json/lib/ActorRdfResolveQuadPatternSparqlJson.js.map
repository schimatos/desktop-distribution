{"version":3,"file":"ActorRdfResolveQuadPatternSparqlJson.js","sourceRoot":"","sources":["ActorRdfResolveQuadPatternSparqlJson.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionHttp, IActorHttpOutput } from '@comunica/bus-http';\nimport type { Bindings, BindingsStream } from '@comunica/bus-query-operation';\nimport type { IActionRdfResolveQuadPattern,\n  IActorRdfResolveQuadPatternOutput } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport {\n  ActorRdfResolveQuadPattern,\n} from '@comunica/bus-rdf-resolve-quad-pattern';\nimport type { ActionContext, Actor, IActorArgs, IActorTest, Mediator } from '@comunica/core';\nimport type { AsyncIterator } from 'asynciterator';\nimport { TransformIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport type * as RDF from 'rdf-js';\nimport { getTerms, getVariables, mapTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory, toSparql } from 'sparqlalgebrajs';\nimport { AsyncIteratorJsonBindings } from './AsyncIteratorJsonBindings';\nconst DF = new DataFactory();\n\n/**\n * A comunica SPARQL JSON RDF Resolve Quad Pattern Actor.\n */\nexport class ActorRdfResolveQuadPatternSparqlJson\n  extends ActorRdfResolveQuadPattern\n  implements IActorRdfResolveQuadPatternSparqlJsonArgs {\n  protected static readonly FACTORY: Factory = new Factory();\n\n  public readonly mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n\n  public constructor(args: IActorRdfResolveQuadPatternSparqlJsonArgs) {\n    super(args);\n  }\n\n  /**\n   * Replace all blank nodes in a pattern with variables.\n   * If the pattern contains no blank nodes the original pattern gets returned.\n   * @param {RDF.BaseQuad} pattern A quad pattern.\n   * @return {RDF.BaseQuad} A quad pattern with no blank nodes.\n   */\n  public static replaceBlankNodes(pattern: RDF.BaseQuad): RDF.BaseQuad {\n    const variableNames: string[] = getVariables(getTerms(pattern)).map(variableTerm => variableTerm.value);\n    // Track the names the blank nodes get mapped to (required if the name has to change)\n    const blankMap: Record<string, string> = {};\n    let changed = false;\n\n    // For every position, convert to a variable if there is a blank node\n    const result = mapTerms(pattern, term => {\n      if (term.termType === 'BlankNode') {\n        let name = term.value;\n        if (blankMap[name]) {\n          name = blankMap[name];\n        } else {\n          if (variableNames.includes(name)) {\n            // Increase index added to name until we find one that is available (2 loops at most)\n            let idx = 0;\n            while (variableNames.includes(`${name}${idx}`)) {\n              ++idx;\n            }\n            name += idx;\n          }\n          blankMap[term.value] = name;\n          variableNames.push(name);\n        }\n        changed = true;\n        return DF.variable(name);\n      }\n      return term;\n    });\n\n    return changed ? result : pattern;\n  }\n\n  /**\n   * Convert a quad pattern to a BGP with only that pattern.\n   * @param {RDF.pattern} quad A quad pattern.\n   * @return {Bgp} A BGP.\n   */\n  public static patternToBgp(pattern: RDF.BaseQuad): Algebra.Bgp {\n    return ActorRdfResolveQuadPatternSparqlJson.FACTORY.createBgp([ ActorRdfResolveQuadPatternSparqlJson.FACTORY\n      .createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph) ]);\n  }\n\n  /**\n   * Convert a quad pattern to a select query for this pattern.\n   * @param {RDF.Quad} pattern A quad pattern.\n   * @return {string} A select query string.\n   */\n  public static patternToSelectQuery(pattern: RDF.BaseQuad): string {\n    const variables: RDF.Variable[] = getVariables(getTerms(pattern));\n    return toSparql(ActorRdfResolveQuadPatternSparqlJson.FACTORY.createProject(\n      ActorRdfResolveQuadPatternSparqlJson.patternToBgp(pattern),\n      variables,\n    ));\n  }\n\n  /**\n   * Convert a quad pattern to a count query for the number of matching triples for this pattern.\n   * @param {RDF.Quad} pattern A quad pattern.\n   * @return {string} A count query string.\n   */\n  public static patternToCountQuery(pattern: RDF.BaseQuad): string {\n    return toSparql(ActorRdfResolveQuadPatternSparqlJson.FACTORY.createProject(\n      ActorRdfResolveQuadPatternSparqlJson.FACTORY.createExtend(\n        ActorRdfResolveQuadPatternSparqlJson.FACTORY.createGroup(\n          ActorRdfResolveQuadPatternSparqlJson.patternToBgp(pattern),\n          [],\n          [ ActorRdfResolveQuadPatternSparqlJson.FACTORY.createBoundAggregate(\n            DF.variable('var0'),\n            'count',\n            ActorRdfResolveQuadPatternSparqlJson.FACTORY.createWildcardExpression(),\n            false,\n          ) ],\n        ),\n        DF.variable('count'),\n        ActorRdfResolveQuadPatternSparqlJson.FACTORY.createTermExpression(DF.variable('var0')),\n      ),\n      [ DF.variable('count') ],\n    ));\n  }\n\n  public async test(action: IActionRdfResolveQuadPattern): Promise<IActorTest> {\n    if (!this.hasContextSingleSourceOfType('sparql', action.context)) {\n      throw new Error(`${this.name} requires a single source with a 'sparql' endpoint to be present in the context.`);\n    }\n    return true;\n  }\n\n  public async run(action: IActionRdfResolveQuadPattern): Promise<IActorRdfResolveQuadPatternOutput> {\n    const endpoint: string = <string> this.getContextSourceUrl(this.getContextSource(action.context));\n    const pattern = ActorRdfResolveQuadPatternSparqlJson.replaceBlankNodes(action.pattern);\n    const selectQuery: string = ActorRdfResolveQuadPatternSparqlJson.patternToSelectQuery(pattern);\n    const countQuery: string = ActorRdfResolveQuadPatternSparqlJson.patternToCountQuery(pattern);\n\n    // Create promise for the metadata containing the estimated count\n    this.queryBindings(endpoint, countQuery, action.context)\n      .then((bindingsStream: BindingsStream) => new Promise(resolve => {\n        bindingsStream.on('data', (bindings: Bindings) => {\n          const count: RDF.Term = bindings.get('?count');\n          if (count) {\n            const totalItems: number = Number.parseInt(count.value, 10);\n            if (Number.isNaN(totalItems)) {\n              return resolve({ totalItems: Infinity });\n            }\n            return resolve({ totalItems });\n          }\n          return resolve({ totalItems: Infinity });\n        });\n        bindingsStream.on('error', () => resolve({ totalItems: Infinity }));\n        bindingsStream.on('end', () => resolve({ totalItems: Infinity }));\n      }))\n      .then(metadata => data.setProperty('metadata', metadata))\n      .catch(error => {\n        data.destroy(error);\n        data.setProperty('metadata', { totalItems: Infinity });\n      });\n\n    // Materialize the queried pattern using each found binding.\n    const data: AsyncIterator<RDF.Quad> & RDF.Stream = new TransformIterator(async() =>\n      (await this.queryBindings(endpoint, selectQuery, action.context))\n        .map((bindings: Bindings) => <RDF.Quad> mapTerms(pattern, (value: RDF.Term) => {\n          if (value.termType === 'Variable') {\n            const boundValue: RDF.Term = bindings.get(`?${value.value}`);\n            if (!boundValue) {\n              data.emit('error',\n                new Error(`The endpoint ${endpoint} failed to provide a binding for ${value.value}`));\n            }\n            return boundValue;\n          }\n          return value;\n        })), { autoStart: false });\n\n    return { data };\n  }\n\n  /**\n   * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n   * @param {string} endpoint A SPARQL endpoint URL.\n   * @param {string} query A SPARQL query string.\n   * @param {ActionContext} context An optional context.\n   * @return {Promise<BindingsStream>} A promise resolving to a stream of bindings.\n   */\n  public async queryBindings(endpoint: string, query: string, context?: ActionContext): Promise<BindingsStream> {\n    return new AsyncIteratorJsonBindings(endpoint, query, context, this.mediatorHttp);\n  }\n}\n\nexport interface IActorRdfResolveQuadPatternSparqlJsonArgs\n  extends IActorArgs<IActionRdfResolveQuadPattern, IActorTest, IActorRdfResolveQuadPatternOutput> {\n  mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n}\n"]}