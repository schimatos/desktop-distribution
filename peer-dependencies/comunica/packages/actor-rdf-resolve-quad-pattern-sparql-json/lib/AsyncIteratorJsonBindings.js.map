{"version":3,"file":"AsyncIteratorJsonBindings.js","sourceRoot":"","sources":["AsyncIteratorJsonBindings.ts"],"names":[],"mappings":";;;AACA,iDAA+C;AAC/C,uEAAyD;AAEzD,iDAAiD;AACjD,uDAAoD;AAEpD;;GAEG;AACH,MAAa,yBAA0B,SAAQ,gCAA0B;IASvE,YAAmB,QAAgB,EAAE,KAAa,EAAE,OAAkC,EAAE,YACI;QAC1F,KAAK,CAAC,EAAE,SAAS,EAAE,KAAK,EAAE,aAAa,EAAE,QAAQ,EAAE,CAAC,CAAC;QAJ/C,gBAAW,GAAG,KAAK,CAAC;QAK1B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,CAAC;IAES,KAAK,CAAC,KAAa,EAAE,IAAgB;QAC7C,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACrB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;YACxB,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,OAAO,CAAC;iBAC9D,IAAI,CAAC,cAAc,CAAC,EAAE;gBACrB,MAAM,iBAAiB,GAAG,IAAI,mCAAgB,CAAC,EAAE,0BAA0B,EAAE,IAAI,EAAE,CAAC;qBACjF,sBAAsB,CAAC,cAAc,CAAC,CAAC;gBAC1C,cAAc,CAAC,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,CAAC,iBAAiB,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;gBAE5E,iBAAiB,CAAC,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;gBAClE,iBAAiB,CAAC,EAAE,CAAC,MAAM,EAAE,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,8BAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC/E,iBAAiB,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;oBAC/B,IAAI,CAAC,KAAK,EAAE,CAAC;gBACf,CAAC,CAAC,CAAC;gBAEH,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YAC3B,CAAC,CAAC;iBACD,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;SAC9C;aAAM;YACL,KAAK,CAAC,KAAK,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;SAC1B;IACH,CAAC;IAES,KAAK,CAAC,mBAAmB,CAAC,QAAgB,EAAE,KAAa,EAAE,OAAuB;QAE1F,MAAM,GAAG,GAAG,GAAG,QAAQ,UAAU,kBAAkB,CAAC,KAAK,CAAC,EAAE,CAAC;QAE7D,mBAAmB;QACnB,MAAM,OAAO,GAAY,IAAI,OAAO,EAAE,CAAC;QACvC,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,iCAAiC,CAAC,CAAC;QAC5D,MAAM,UAAU,GAAgB,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE,OAAO,EAAE,EAAC,CAAC;QAC1E,MAAM,YAAY,GAAqB,MAAM,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;QAEnF,6DAA6D;QAC7D,qGAAqG;QACrG,MAAM,cAAc,GAA0B,oBAAS,CAAC,cAAc,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QAE1F,2DAA2D;QAC3D,IAAI,CAAC,YAAY,CAAC,EAAE,EAAE;YACpB,MAAM,IAAI,KAAK,CACb,4BAA4B,QAAQ,eAAe,YAAY,CAAC,UAAU,KAAK,YAAY,CAAC,MAAM,GAAG,CACtG,CAAC;SACH;QAED,OAAO,cAAc,CAAC;IACxB,CAAC;CACF;AAhED,8DAgEC","sourcesContent":["import type { IActionHttp, IActorHttpOutput } from '@comunica/bus-http';\nimport { ActorHttp } from '@comunica/bus-http';\nimport { Bindings } from '@comunica/bus-query-operation';\nimport type { ActionContext, Actor, IActorTest, Mediator } from '@comunica/core';\nimport { BufferedIterator } from 'asynciterator';\nimport { SparqlJsonParser } from 'sparqljson-parse';\n\n/**\n * An AsyncIterator that executes a SPARQL query against an endpoint, parses each binding, and emits it in this stream.\n */\nexport class AsyncIteratorJsonBindings extends BufferedIterator<Bindings> {\n  private readonly endpoint: string;\n  private readonly query: string;\n  private readonly context?: ActionContext;\n  private readonly mediatorHttp: Mediator<Actor<IActionHttp, IActorTest, IActorHttpOutput>,\n  IActionHttp, IActorTest, IActorHttpOutput>;\n\n  private initialized = false;\n\n  public constructor(endpoint: string, query: string, context: ActionContext | undefined, mediatorHttp: Mediator<\n  Actor<IActionHttp, IActorTest, IActorHttpOutput>, IActionHttp, IActorTest, IActorHttpOutput>) {\n    super({ autoStart: false, maxBufferSize: Infinity });\n    this.endpoint = endpoint;\n    this.query = query;\n    this.context = context;\n    this.mediatorHttp = mediatorHttp;\n  }\n\n  protected _read(count: number, done: () => void): void {\n    if (!this.initialized) {\n      this.initialized = true;\n      this.fetchBindingsStream(this.endpoint, this.query, this.context)\n        .then(responseStream => {\n          const rawBindingsStream = new SparqlJsonParser({ prefixVariableQuestionMark: true })\n            .parseJsonResultsStream(responseStream);\n          responseStream.on('error', error => rawBindingsStream.emit('error', error));\n\n          rawBindingsStream.on('error', error => this.emit('error', error));\n          rawBindingsStream.on('data', rawBindings => this._push(Bindings(rawBindings)));\n          rawBindingsStream.on('end', () => {\n            this.close();\n          });\n\n          super._read(count, done);\n        })\n        .catch(error => this.emit('error', error));\n    } else {\n      super._read(count, done);\n    }\n  }\n\n  protected async fetchBindingsStream(endpoint: string, query: string, context?: ActionContext):\n  Promise<NodeJS.ReadableStream> {\n    const url = `${endpoint}?query=${encodeURIComponent(query)}`;\n\n    // Initiate request\n    const headers: Headers = new Headers();\n    headers.append('Accept', 'application/sparql-results+json');\n    const httpAction: IActionHttp = { context, input: url, init: { headers }};\n    const httpResponse: IActorHttpOutput = await this.mediatorHttp.mediate(httpAction);\n\n    // Wrap WhatWG readable stream into a Node.js readable stream\n    // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n    const responseStream: NodeJS.ReadableStream = ActorHttp.toNodeReadable(httpResponse.body);\n\n    // Emit an error if the server returned an invalid response\n    if (!httpResponse.ok) {\n      throw new Error(\n        `Invalid SPARQL endpoint (${endpoint}) response: ${httpResponse.statusText} (${httpResponse.status})`,\n      );\n    }\n\n    return responseStream;\n  }\n}\n"]}