{"version":3,"file":"ActorQueryOperation.js","sourceRoot":"","sources":["ActorQueryOperation.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ActionContext, IAction, IActorArgs, IActorTest, Mediator } from '@comunica/core';\nimport { Actor } from '@comunica/core';\nimport type { AsyncIterator } from 'asynciterator';\nimport type * as RDF from 'rdf-js';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { Bindings, BindingsStream } from './Bindings';\nimport { materializeOperation } from './Bindings';\n\n/**\n * @type {string} Context entry for current metadata.\n *                I.e., the metadata that was used to determine the next BGP operation.\n * @value {any} A metadata hash.\n */\nexport const KEY_CONTEXT_BGP_CURRENTMETADATA = '@comunica/bus-query-operation:bgpCurrentMetadata';\n/**\n * @type {string} Context entry for an array of parent metadata.\n *                I.e., an array of the metadata that was present before materializing the current BGP operations.\n *                This can be passed in 'bgp' actions.\n *                The array entries should correspond to the pattern entries in the BGP.\n * @value {any} An array of metadata hashes.\n */\nexport const KEY_CONTEXT_BGP_PARENTMETADATA = '@comunica/bus-query-operation:bgpParentMetadata';\n/**\n * @type {string} Context entry for indicating which patterns were bound from variables.\n *                I.e., an array of the same length as the value of KEY_CONTEXT_BGP_PARENTMETADATA,\n *                where each array value corresponds to the pattern bindings for the corresponding pattern.\n * @value {any} An array of {@link IPatternBindings}.\n */\nexport const KEY_CONTEXT_BGP_PATTERNBINDINGS = '@comunica/bus-query-operation:bgpPatternBindings';\n/**\n * @type {string} Context entry for parent metadata.\n *                I.e., the metadata that was present before materializing the current operation.\n *                This can be passed in 'pattern' actions.\n * @value {any} A metadata hash.\n */\nexport const KEY_CONTEXT_PATTERN_PARENTMETADATA = '@comunica/bus-query-operation:patternParentMetadata';\n/**\n * @type {string} Context entry for query's base IRI.\n * @value {any} A string.\n */\nexport const KEY_CONTEXT_BASEIRI = '@comunica/actor-init-sparql:baseIRI';\n/**\n * @type {string} A timestamp representing the current time.\n *                This is required for certain SPARQL operations such as NOW().\n * @value {any} a date.\n */\nexport const KEY_CONTEXT_QUERY_TIMESTAMP = '@comunica/actor-init-sparql:queryTimestamp';\n\n/**\n * A comunica actor for query-operation events.\n *\n * Actor types:\n * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.\n * * Test:   <none>\n * * Output: IActorQueryOperationOutput: A bindings stream.\n *\n * @see IActionQueryOperation\n * @see IActorQueryOperationOutput\n */\nexport abstract class ActorQueryOperation extends Actor<IActionQueryOperation, IActorTest, IActorQueryOperationOutput> {\n  protected constructor(args: IActorArgs<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>) {\n    super(args);\n  }\n\n  /**\n   * Safely cast a query operation output to a bindings output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @return {IActorQueryOperationOutputBindings} A bindings query operation output.\n   */\n  public static getSafeBindings(output: IActorQueryOperationOutput): IActorQueryOperationOutputBindings {\n    ActorQueryOperation.validateQueryOutput(output, 'bindings');\n    return <IActorQueryOperationOutputBindings> output;\n  }\n\n  /**\n   * Safely cast a query operation output to a quads output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @return {IActorQueryOperationOutputQuads} A quads query operation output.\n   */\n  public static getSafeQuads(output: IActorQueryOperationOutput): IActorQueryOperationOutputQuads {\n    ActorQueryOperation.validateQueryOutput(output, 'quads');\n    return <IActorQueryOperationOutputQuads> output;\n  }\n\n  /**\n   * Safely cast a query operation output to a boolean output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @return {IActorQueryOperationOutputBoolean} A boolean query operation output.\n   */\n  public static getSafeBoolean(output: IActorQueryOperationOutput): IActorQueryOperationOutputBoolean {\n    ActorQueryOperation.validateQueryOutput(output, 'boolean');\n    return <IActorQueryOperationOutputBoolean> output;\n  }\n\n  /**\n   * Safely cast a query operation output to an update output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @return {IActorQueryOperationOutputUpdate} An update query operation output.\n   */\n  public static getSafeUpdate(output: IActorQueryOperationOutput): IActorQueryOperationOutputUpdate {\n    ActorQueryOperation.validateQueryOutput(output, 'update');\n    return <IActorQueryOperationOutputUpdate> output;\n  }\n\n  /**\n   * Convert a metadata callback to a lazy callback where the response value is cached.\n   * @param {() => Promise<{[p: string]: any}>} metadata A metadata callback\n   * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.\n   */\n  public static cachifyMetadata<T extends (() => Promise<Record<string, any>>)\n  | (undefined | (() => Promise<Record<string, any>>))>(metadata: T): T {\n    let lastReturn: Promise<Record<string, any>>;\n    // eslint-disable-next-line no-return-assign,@typescript-eslint/no-misused-promises\n    return <T> (metadata && (() => (lastReturn || (lastReturn = metadata()))));\n  }\n\n  /**\n   * Throw an error if the output type does not match the expected type.\n   * @param {IActorQueryOperationOutput} output A query operation output.\n   * @param {string} expectedType The expected output type.\n   */\n  public static validateQueryOutput(output: IActorQueryOperationOutput, expectedType: string): void {\n    if (output.type !== expectedType) {\n      throw new Error(`Invalid query output type: Expected '${expectedType}' but got '${output.type}'`);\n    }\n  }\n\n  /**\n   * Create an options object that can be used to construct a sparqlee evaluator.\n   * @param context An action context.\n   * @param mediatorQueryOperation An optional query query operation mediator.\n   *                               If defined, the existence resolver will be defined as `exists`.\n   */\n  public static getExpressionContext(context: ActionContext, mediatorQueryOperation?: Mediator<\n  Actor<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>,\n  IActionQueryOperation, IActorTest, IActorQueryOperationOutput>): IExpressionContext {\n    if (context) {\n      const now: Date = context.get(KEY_CONTEXT_QUERY_TIMESTAMP);\n      const baseIRI: string = context.get(KEY_CONTEXT_BASEIRI);\n      return {\n        now,\n        baseIRI,\n        ...mediatorQueryOperation ?\n          {\n            exists: ActorQueryOperation.createExistenceResolver(context, mediatorQueryOperation),\n          } :\n          {},\n      };\n    }\n    return {};\n  }\n\n  /**\n   * Create an existence resolver for usage within an expression context.\n   * @param context An action context.\n   * @param mediatorQueryOperation A query operation mediator.\n   */\n  public static createExistenceResolver(context: ActionContext, mediatorQueryOperation: Mediator<\n  Actor<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>,\n  IActionQueryOperation, IActorTest, IActorQueryOperationOutput>):\n    (expr: Algebra.ExistenceExpression, bindings: Bindings) => Promise<boolean> {\n    return async(expr, bindings) => {\n      const operation = materializeOperation(expr.input, bindings);\n\n      const outputRaw = await mediatorQueryOperation.mediate({ operation, context });\n      const output = ActorQueryOperation.getSafeBindings(outputRaw);\n\n      return new Promise(\n        (resolve, reject) => {\n          output.bindingsStream.on('end', () => {\n            resolve(false);\n          });\n\n          output.bindingsStream.on('error', reject);\n\n          output.bindingsStream.on('data', () => {\n            output.bindingsStream.close();\n            resolve(true);\n          });\n        },\n      )\n        .then((exists: boolean) => expr.not ? !exists : exists);\n    };\n  }\n}\n\nexport interface IExpressionContext {\n  now?: Date;\n  baseIRI?: string;\n  // Exists?: (expr: Algebra.ExistenceExpression, bindings: Bindings) => Promise<boolean>;\n  // bnode?: (input?: string) => Promise<RDF.BlankNode>;\n}\n\nexport interface IActionQueryOperation extends IAction {\n  /**\n   * The query operation to handle.\n   */\n  operation: Algebra.Operation;\n}\n\n/**\n * Query operation output.\n * @see IActorQueryOperationOutputBindings, IActorQueryOperationOutputQuads, IActorQueryOperationOutputBoolean,\n * IActorQueryOperationOutputUpdate\n */\nexport type IActorQueryOperationOutput =\n  IActorQueryOperationOutputStream |\n  IActorQueryOperationOutputQuads |\n  IActorQueryOperationOutputBoolean |\n  IActorQueryOperationOutputUpdate;\nexport interface IActorQueryOperationOutputBase {\n  /**\n   * The type of output.\n   */\n  type: string;\n  /**\n   * The resulting action context.\n   */\n  context?: ActionContext;\n}\n\n/**\n * Super interface for query operation outputs that represent some for of stream.\n * @see IActorQueryOperationOutputBindings, IActorQueryOperationOutputQuads\n */\nexport interface IActorQueryOperationOutputStream extends IActorQueryOperationOutputBase {\n  /**\n   * Callback that returns a promise that resolves to the metadata about the stream.\n   * This can contain things like the estimated number of total stream elements,\n   * or the order in which the bindings appear.\n   * This callback can be invoked multiple times.\n   * The actors that return this metadata will make sure that multiple calls properly cache this promise.\n   * Metadata will not be collected until this callback is invoked.\n   */\n  metadata?: () => Promise<Record<string, any>>;\n}\n\n/**\n * Helper function to get the metadata of an action output.\n * @param actionOutput An action output, with an optional metadata function.\n * @return The metadata.\n */\nexport function getMetadata(actionOutput: IActorQueryOperationOutputStream): Promise<Record<string, any>> {\n  if (!actionOutput.metadata) {\n    return Promise.resolve({});\n  }\n  return actionOutput.metadata();\n}\n\n/**\n * Query operation output for a bindings stream.\n * For example: SPARQL SELECT results\n */\nexport interface IActorQueryOperationOutputBindings extends IActorQueryOperationOutputStream {\n  /**\n   * The type of output.\n   */\n  type: 'bindings';\n  /**\n   * The stream of bindings resulting from the given operation.\n   */\n  bindingsStream: BindingsStream;\n  /**\n   * The list of variable names (without '?') for which bindings are provided in the stream.\n   */\n  variables: string[];\n  /**\n   * If any of the bindings could contain an undefined variable binding.\n   * If this is false, then all variables are guaranteed to have a defined bound value in the bindingsStream.\n   */\n  canContainUndefs: boolean;\n}\n\n/**\n * Query operation output for quads.\n * For example: SPARQL CONSTRUCT results\n */\nexport interface IActorQueryOperationOutputQuads extends IActorQueryOperationOutputStream {\n  /**\n   * The type of output.\n   */\n  type: 'quads';\n  /**\n   * The stream of quads.\n   */\n  quadStream: QuadStream;\n}\n\n/**\n * Query operation output for quads.\n * For example: SPARQL ASK results\n */\nexport interface IActorQueryOperationOutputBoolean extends IActorQueryOperationOutputBase {\n  /**\n   * The type of output.\n   */\n  type: 'boolean';\n  /**\n   * A promise resolving to the boolean output of the operation.\n   */\n  booleanResult: Promise<boolean>;\n\n}\n\nexport interface IActorQueryOperationOutputUpdate extends IActorQueryOperationOutputBase {\n  /**\n   * The type of output.\n   */\n  type: 'update';\n  /**\n   * The stream of quads that were inserted.\n   * Undefined if the operation did not have to insert anything.\n   */\n  quadStreamInserted?: QuadStream;\n  /**\n   * The stream of quads that were deleted.\n   * Undefined if the operation did not have to delete anything.\n   */\n  quadStreamDeleted?: QuadStream;\n}\n\n/**\n * A stream of Quads\n */\nexport type QuadStream = RDF.Stream & AsyncIterator<RDF.Quad>;\n\n/**\n * Binds a quad pattern term's position to a variable.\n */\nexport type IPatternBindings = Record<string, RDF.Variable>;\n"]}