{"version":3,"file":"ActorQueryOperationTyped.js","sourceRoot":"","sources":["ActorQueryOperationTyped.ts"],"names":[],"mappings":";;;AAIA,+DAA4D;AAE5D;;GAEG;AACU,QAAA,0BAA0B,GAAG,yCAAyC,CAAC;AAEpF;;GAEG;AACH,MAAsB,wBAAsD,SAAQ,yCAAmB;IAGrG,YAAsB,IAA+E,EACnG,aAAqB;QACrB,KAAK,CAAC,gCAAW,IAAI,KAAE,aAAa,GAAE,CAAC,CAAC;QACxC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;SACvE;IACH,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAA6B;QAC7C,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;SAC7E;QACD,IAAI,MAAM,CAAC,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,aAAa,EAAE;YAChD,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,IAAI,kBAAkB,IAAI,CAAC,aAAa,wBACpE,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;SAC5B;QACD,MAAM,SAAS,GAAU,MAAM,CAAC,SAAS,CAAC;QAC1C,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;IACvD,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAA6B;QAC5C,MAAM,SAAS,GAAU,MAAM,CAAC,SAAS,CAAC;QAC1C,MAAM,UAAU,GAAG,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,kCAA0B,EAAE,SAAS,CAAC,CAAC;QAC/F,MAAM,MAAM,GAA+B,MAAM,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;QAC1F,IAAwC,MAAO,CAAC,QAAQ,EAAE;YACpB,MAAO,CAAC,QAAQ;gBAClD,yCAAmB,CAAC,eAAe,CAAqC,MAAO,CAAC,QAAQ,CAAC,CAAC;SAC7F;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;CAMF;AAtCD,4DAsCC","sourcesContent":["import type { ActionContext, IActorArgs, IActorTest } from '@comunica/core';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { IActionQueryOperation, IActorQueryOperationOutput,\n  IActorQueryOperationOutputStream } from './ActorQueryOperation';\nimport { ActorQueryOperation } from './ActorQueryOperation';\n\n/**\n * @type {string} Context entry for the current query operation.\n */\nexport const KEY_CONTEXT_QUERYOPERATION = '@comunica/bus-query-operation:operation';\n\n/**\n * A base implementation for query operation actors for a specific operation type.\n */\nexport abstract class ActorQueryOperationTyped<O extends Algebra.Operation> extends ActorQueryOperation {\n  public readonly operationName: string;\n\n  protected constructor(args: IActorArgs<IActionQueryOperation, IActorTest, IActorQueryOperationOutput>,\n    operationName: string) {\n    super(<any> { ...args, operationName });\n    if (!this.operationName) {\n      throw new Error('A valid \"operationName\" argument must be provided.');\n    }\n  }\n\n  public async test(action: IActionQueryOperation): Promise<IActorTest> {\n    if (!action.operation) {\n      throw new Error('Missing field \\'operation\\' in a query operation action.');\n    }\n    if (action.operation.type !== this.operationName) {\n      throw new Error(`Actor ${this.name} only supports ${this.operationName} operations, but got ${\n        action.operation.type}`);\n    }\n    const operation: O = <O> action.operation;\n    return this.testOperation(operation, action.context);\n  }\n\n  public async run(action: IActionQueryOperation): Promise<IActorQueryOperationOutput> {\n    const operation: O = <O> action.operation;\n    const subContext = action.context && action.context.set(KEY_CONTEXT_QUERYOPERATION, operation);\n    const output: IActorQueryOperationOutput = await this.runOperation(operation, subContext);\n    if ((<IActorQueryOperationOutputStream> output).metadata) {\n      (<IActorQueryOperationOutputStream> output).metadata =\n        ActorQueryOperation.cachifyMetadata((<IActorQueryOperationOutputStream> output).metadata);\n    }\n    return output;\n  }\n\n  protected abstract testOperation(operation: O, context: ActionContext | undefined): Promise<IActorTest>;\n\n  protected abstract runOperation(operation: O, context: ActionContext | undefined):\n  Promise<IActorQueryOperationOutput>;\n}\n"]}