{"version":3,"file":"Bindings.js","sourceRoot":"","sources":["Bindings.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AsyncIterator } from 'asynciterator';\nimport { Map } from 'immutable';\nimport type * as RDF from 'rdf-js';\nimport { termToString } from 'rdf-string';\nimport type { Algebra, Factory } from 'sparqlalgebrajs';\nimport { Util } from 'sparqlalgebrajs';\n\n/**\n * A stream of bindings.\n *\n * Next to the list of available variables,\n * an optional metadata hash can be present.\n *\n * @see Bindings\n */\nexport type BindingsStream = AsyncIterator<Bindings>;\n\n/**\n * An immutable solution mapping object.\n * This maps variables to a terms.\n *\n * Variables are represented as strings containing the variable name prefixed with '?'.\n * Blank nodes are represented as strings containing the blank node name prefixed with '_:'.\n * Terms are named nodes, literals or the default graph.\n */\nexport type Bindings = Map<string, RDF.Term>;\n\n/**\n * A convenience constructor for bindings based on a given hash.\n * @param {{[p: string]: RDF.Term}} hash A hash that maps variable names to terms.\n * @return {Bindings} The immutable bindings from the hash.\n * @constructor\n */\n// eslint-disable-next-line no-redeclare\nexport function Bindings(hash: Record<string, RDF.Term>): Bindings {\n  return Map(hash);\n}\n\n/**\n * Check if the given object is a bindings object.\n * @param maybeBindings Any object.\n * @return {boolean} If the object is a bindings object.\n */\nexport function isBindings(maybeBindings: any): boolean {\n  return Map.isMap(maybeBindings);\n}\n\n/**\n * Convert the given object to a bindings object if it is not a bindings object yet.\n * If it already is a bindings object, return the object as-is.\n * @param maybeBindings Any object.\n * @return {Bindings} A bindings object.\n */\nexport function ensureBindings(maybeBindings: any): Bindings {\n  return isBindings(maybeBindings) ? maybeBindings : Bindings(maybeBindings);\n}\n\n/**\n * Materialize a term with the given binding.\n *\n * If the given term is a variable,\n * and that variable exist in the given bindings object,\n * the value of that binding is returned.\n * In all other cases, the term itself is returned.\n *\n * @param {RDF.Term} term A term.\n * @param {Bindings} bindings A bindings object.\n * @return {RDF.Term} The materialized term.\n */\nexport function materializeTerm(term: RDF.Term, bindings: Bindings): RDF.Term {\n  if (term.termType === 'Variable') {\n    const value: RDF.Term = bindings.get(termToString(term));\n    if (value) {\n      return value;\n    }\n  }\n  return term;\n}\n\n/**\n * Materialize the given operation (recursively) with the given bindings.\n * Essentially, all variables in the given operation will be replaced\n * by the terms bound to the variables in the given bindings.\n * @param {Operation} operation SPARQL algebra operation.\n * @param {Bindings} bindings A bindings object.\n * @param {boolean} strictTargetVariables If target variable bindings (such as on SELECT or BIND) should not be allowed.\n * @return Algebra.Operation A new operation materialized with the given bindings.\n */\nexport function materializeOperation(operation: Algebra.Operation, bindings: Bindings,\n  strictTargetVariables = false): Algebra.Operation {\n  return Util.mapOperation(operation, {\n    path(op: Algebra.Path, factory: Factory) {\n      // Materialize variables in a path expression.\n      // The predicate expression will be recursed.\n      return {\n        recurse: false,\n        result: factory.createPath(\n          materializeTerm(op.subject, bindings),\n          op.predicate,\n          materializeTerm(op.object, bindings),\n          materializeTerm(op.graph, bindings),\n        ),\n      };\n    },\n    pattern(op: Algebra.Pattern, factory: Factory) {\n      // Materialize variables in the quad pattern.\n      return {\n        recurse: false,\n        result: factory.createPattern(\n          materializeTerm(op.subject, bindings),\n          materializeTerm(op.predicate, bindings),\n          materializeTerm(op.object, bindings),\n          materializeTerm(op.graph, bindings),\n        ),\n      };\n    },\n    extend(op: Algebra.Extend) {\n      // Materialize an extend operation.\n      // If strictTargetVariables is true, we throw if the extension target variable is attempted to be bound.\n      // Otherwise, we remove the extend operation.\n      if (bindings.has(termToString(op.variable))) {\n        if (strictTargetVariables) {\n          throw new Error(`Tried to bind variable ${termToString(op.variable)} in a BIND operator.`);\n        } else {\n          return {\n            recurse: true,\n            result: materializeOperation(op.input, bindings, strictTargetVariables),\n          };\n        }\n      }\n      return {\n        recurse: true,\n        result: op,\n      };\n    },\n    group(op: Algebra.Group, factory: Factory) {\n      // Materialize a group operation.\n      // If strictTargetVariables is true, we throw if the group target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(termToString(variable))) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a GROUP BY operator.`);\n          }\n        }\n        return {\n          recurse: true,\n          result: op,\n        };\n      }\n      const variables = op.variables.filter(variable => !bindings.has(termToString(variable)));\n      return {\n        recurse: true,\n        result: factory.createGroup(\n          op.input,\n          variables,\n          op.aggregates,\n        ),\n      };\n    },\n    project(op: Algebra.Project, factory: Factory) {\n      // Materialize a project operation.\n      // If strictTargetVariables is true, we throw if the project target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(termToString(variable))) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a SELECT operator.`);\n          }\n        }\n        return {\n          recurse: true,\n          result: op,\n        };\n      }\n      const variables = op.variables.filter(variable => !bindings.has(termToString(variable)));\n      return {\n        recurse: true,\n        result: factory.createProject(\n          op.input,\n          variables,\n        ),\n      };\n    },\n    values(op: Algebra.Values, factory: Factory) {\n      // Materialize a values operation.\n      // If strictTargetVariables is true, we throw if the values target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables and their bindings.\n      if (strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(termToString(variable))) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a VALUES operator.`);\n          }\n        }\n      } else {\n        const variables = op.variables.filter(variable => !bindings.has(termToString(variable)));\n        const valueBindings = op.bindings.map(binding => {\n          const newBinding = { ...binding };\n          bindings.forEach((value: RDF.NamedNode, key: string) => delete newBinding[key]);\n          return newBinding;\n        });\n        return {\n          recurse: true,\n          result: factory.createValues(\n            variables,\n            valueBindings,\n          ),\n        };\n      }\n      return {\n        recurse: false,\n        result: op,\n      };\n    },\n    expression(op: Algebra.Expression, factory: Factory) {\n      if (op.expressionType === 'term') {\n        // Materialize a term expression\n        return {\n          recurse: false,\n          result: factory.createTermExpression(materializeTerm(op.term, bindings)),\n        };\n      }\n      if (op.expressionType === 'aggregate' &&\n        'variable' in op &&\n        bindings.has(termToString(<RDF.Variable> op.variable))) {\n        // Materialize a bound aggregate operation.\n        // If strictTargetVariables is true, we throw if the expression target variable is attempted to be bound.\n        // Otherwise, we ignore this operation.\n        if (strictTargetVariables) {\n          throw new Error(`Tried to bind ${termToString(op.variable)} in a ${op.aggregator} aggregate.`);\n        } else {\n          return {\n            recurse: true,\n            result: op,\n          };\n        }\n      }\n      return {\n        recurse: true,\n        result: op,\n      };\n    },\n  });\n}\n"]}