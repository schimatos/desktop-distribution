{"version":3,"file":"ActorRdfJoin.js","sourceRoot":"","sources":["ActorRdfJoin.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Bindings, IActorQueryOperationOutput,\n  IActorQueryOperationOutputBindings } from '@comunica/bus-query-operation';\nimport type { IAction, IActorArgs } from '@comunica/core';\nimport { Actor } from '@comunica/core';\nimport type { IMediatorTypeIterations } from '@comunica/mediatortype-iterations';\nimport { ArrayIterator } from 'asynciterator';\nimport type * as RDF from 'rdf-js';\n\n/**\n * A comunica actor for joining 2 binding streams.\n *\n * Actor types:\n * * Input:  IActionRdfJoin:      The streams that need to be joined.\n * * Test:   <none>\n * * Output: IActorRdfJoinOutput: The resulting joined stream.\n *\n * @see IActionRdfJoin\n * @see IActorQueryOperationOutput\n */\nexport abstract class ActorRdfJoin extends Actor<IActionRdfJoin, IMediatorTypeIterations, IActorQueryOperationOutput> {\n  /**\n   * Can be used by subclasses to indicate the max or min number of streams that can be joined.\n   * 0 for infinity.\n   * By default, this indicates the max number, but can be inverted by setting limitEntriesMin to true.\n   */\n  protected limitEntries: number;\n  /**\n   * If true, the limitEntries field is a lower limit,\n   * otherwise, it is an upper limit.\n   */\n  protected limitEntriesMin: boolean;\n  /**\n   * If this actor can handle undefs in the bindings.\n   */\n  protected canHandleUndefs: boolean;\n\n  public constructor(args: IActorArgs<IActionRdfJoin, IMediatorTypeIterations, IActorQueryOperationOutput>,\n    limitEntries?: number, limitEntriesMin?: boolean, canHandleUndefs?: boolean) {\n    super(args);\n    this.limitEntries = limitEntries ?? Infinity;\n    this.limitEntriesMin = limitEntriesMin ?? false;\n    this.canHandleUndefs = canHandleUndefs ?? false;\n  }\n\n  /**\n   * Returns an array containing all the variable names that occur in all bindings streams.\n   * @param {IActionRdfJoin} action\n   * @returns {string[]}\n   */\n  public static overlappingVariables(action: IActionRdfJoin): string[] {\n    const variables = action.entries.map(entry => entry.variables);\n    let baseArray = variables[0];\n    for (const array of variables.slice(1)) {\n      baseArray = baseArray.filter(el => array.includes(el));\n    }\n    return baseArray;\n  }\n\n  /**\n   * Returns the variables that will occur in the joined bindings.\n   * @param {IActionRdfJoin} action\n   * @returns {string[]}\n   */\n  public static joinVariables(action: IActionRdfJoin): string[] {\n    const variables = action.entries.map(entry => entry.variables);\n    const withDuplicates = variables.reduce((acc, it) => [ ...acc, ...it ], []);\n    return [ ...new Set(withDuplicates) ];\n  }\n\n  /**\n   * Returns the result of joining bindings, or `null` if no join is possible.\n   * @param {Bindings[]} bindings\n   * @returns {Bindings}\n   */\n  public static join(...bindings: Bindings[]): Bindings | null {\n    try {\n      return bindings.reduce((acc: Bindings, val: Bindings) => acc.mergeWith((left: RDF.Term, right: RDF.Term) => {\n        if (!left.equals(right)) {\n          throw new Error('Join failure');\n        }\n        return left;\n      }, val));\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Checks if all metadata objects are present in the action, and if they have the specified key.\n   * @param {IActionRdfJoin} action\n   * @param {string} key\n   * @returns {boolean}\n   */\n  public static async iteratorsHaveMetadata(action: IActionRdfJoin, key: string): Promise<boolean> {\n    return Promise.all(action.entries.map(async entry => {\n      if (!entry.metadata) {\n        throw new Error('Missing metadata');\n      }\n      const metadata = await entry.metadata();\n      if (!(key in metadata)) {\n        throw new Error('Missing metadata value');\n      }\n    })).then(() => true).catch(() => false);\n  }\n\n  /**\n   * Default test function for join actors.\n   * Checks whether all iterators have metadata.\n   * If yes: call the abstract getIterations method, if not: return Infinity.\n   * @param {IActionRdfJoin} action The input action containing the relevant iterators\n   * @returns {Promise<IMediatorTypeIterations>} The calculated estime.\n   */\n  public async test(action: IActionRdfJoin): Promise<IMediatorTypeIterations> {\n    // Allow joining of one or zero streams\n    if (action.entries.length <= 1) {\n      return { iterations: 0 };\n    }\n\n    // Check if this actor can handle the given number of streams\n    if (this.limitEntriesMin ? action.entries.length < this.limitEntries : action.entries.length > this.limitEntries) {\n      throw new Error(`${this.name} requires ${this.limitEntries\n      } sources at ${this.limitEntriesMin ? 'least' : 'most'\n      }. The input contained ${action.entries.length}.`);\n    }\n\n    // Check if all streams are bindings streams\n    for (const entry of action.entries) {\n      if (entry.type !== 'bindings') {\n        throw new Error(`Invalid type of a join entry: Expected 'bindings' but got '${entry.type}'`);\n      }\n    }\n\n    // Check if this actor can handle undefs\n    if (!this.canHandleUndefs) {\n      for (const entry of action.entries) {\n        if (entry.canContainUndefs) {\n          throw new Error(`Actor ${this.name} can not join streams containing undefs`);\n        }\n      }\n    }\n\n    if (!await ActorRdfJoin.iteratorsHaveMetadata(action, 'totalItems')) {\n      return { iterations: Infinity };\n    }\n\n    return { iterations: await this.getIterations(action) };\n  }\n\n  /**\n   * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise\n   * @param {IActionRdfJoin} action\n   * @returns {Promise<IActorQueryOperationOutput>}\n   */\n  public async run(action: IActionRdfJoin): Promise<IActorQueryOperationOutputBindings> {\n    if (action.entries.length === 0) {\n      return {\n        bindingsStream: new ArrayIterator([], { autoStart: false }),\n        metadata: () => Promise.resolve({ totalItems: 0 }),\n        type: 'bindings',\n        variables: [],\n        canContainUndefs: false,\n      };\n    }\n    if (action.entries.length === 1) {\n      return action.entries[0];\n    }\n\n    const result = this.getOutput(action);\n\n    function totalItems(): Promise<number> {\n      return Promise.all(action.entries\n        .map(entry => (<() => Promise<Record<string, any>>> entry.metadata)()))\n        .then(metadatas => metadatas.reduce((acc, val) => acc * val.totalItems, 1));\n    }\n\n    if (await ActorRdfJoin.iteratorsHaveMetadata(action, 'totalItems')) {\n      // Update the result promise to also add the estimated total items\n      const unwrapped = await result;\n      if (unwrapped.metadata) {\n        const oldMetadata = unwrapped.metadata;\n        unwrapped.metadata = () => oldMetadata().then(async metadata => {\n          // Don't overwrite metadata if it was generated by implementation\n          if (!('totalItems' in metadata)) {\n            metadata.totalItems = await totalItems();\n          }\n          return metadata;\n        });\n      } else {\n        unwrapped.metadata = () => totalItems().then(totalItemsValue => ({ totalItems: totalItemsValue }));\n      }\n      return unwrapped;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns the resulting output for joining the given entries.\n   * This is called after removing the trivial cases in run.\n   * @param {IActionRdfJoin} action\n   * @returns {Promise<IActorQueryOperationOutput>}\n   */\n  protected abstract getOutput(action: IActionRdfJoin): Promise<IActorQueryOperationOutputBindings>;\n\n  /**\n   * Used when calculating the number of iterations in the test function.\n   * All metadata objects are guaranteed to have a value for the `totalItems` key.\n   * @param {IActionRdfJoin} action\n   * @returns {number} The estimated number of iterations when joining the given iterators.\n   */\n  protected abstract getIterations(action: IActionRdfJoin): Promise<number>;\n}\n\nexport interface IActionRdfJoin extends IAction {\n\n  /**\n   * The list of streams and their corresponding metadata that need to be joined.\n   */\n  entries: IActorQueryOperationOutputBindings[];\n}\n"]}