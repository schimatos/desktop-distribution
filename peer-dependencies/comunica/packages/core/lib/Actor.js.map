{"version":3,"file":"Actor.js","sourceRoot":"","sources":["Actor.ts"],"names":[],"mappings":"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","sourcesContent":["import { Map } from 'immutable';\nimport type { Bus } from './Bus';\nimport type { Logger } from './Logger';\nimport { KEY_CONTEXT_LOG } from './Logger';\n\n/**\n * An actor can act on messages of certain types and provide output of a certain type.\n *\n * The flow of an actor is as follows:\n * 1. Send a message to {@link Actor#test} to test if an actor can run that action.\n * 2. If the actor can reply to the message, let the actor run the action using {@link Actor#run}.\n *\n * An actor is typically subscribed to a bus,\n * using which the applicability to an action can be tested.\n *\n * @see Bus\n *\n * @template I The input type of an actor.\n * @template T The test type of an actor.\n * @template O The output type of an actor.\n */\nexport abstract class Actor<I extends IAction, T extends IActorTest, O extends IActorOutput> implements\n    IActorArgs<I, T, O> {\n  public readonly name: string;\n  public readonly bus: Bus<Actor<I, T, O>, I, T, O>;\n  public readonly beforeActors: Actor<I, T, O>[] = [];\n\n  /**\n   * All enumerable properties from the `args` object are inherited to this actor.\n   *\n   * The actor will subscribe to the given bus when this constructor is called.\n   *\n   * @param {IActorArgs<I extends IAction, T extends IActorTest, O extends IActorOutput>} args Arguments object\n   * @param {string} args.name The name for this actor.\n   * @param {Bus<A extends Actor<I, T, O>, I extends IAction, T extends IActorTest, O extends IActorOutput>} args.bus\n   *        The bus this actor subscribes to.\n   * @throws When required arguments are missing.\n   */\n  protected constructor(args: IActorArgs<I, T, O>) {\n    Object.assign(this, args);\n    this.bus.subscribe(this);\n    if (this.beforeActors.length > 0) {\n      this.bus.addDependencies(this, this.beforeActors);\n    }\n  }\n\n  /**\n   * Get the logger from the given context.\n   * @param {ActionContext} context An optional context.\n   * @return {Logger} The logger or undefined.\n   */\n  public static getContextLogger(context?: ActionContext): Logger | undefined {\n    return context && context.get(KEY_CONTEXT_LOG);\n  }\n\n  /**\n   * Check if this actor can run the given action,\n   * without actually running it.\n   *\n   * @param {I} action The action to test.\n   * @return {Promise<T>} A promise that resolves to the test result.\n   */\n  public abstract test(action: I): Promise<T>;\n\n  /**\n   * Run the given action on this actor.\n   *\n   * In most cases, this method should not be called directly.\n   * Instead, {@link #runObservable} should be called.\n   *\n   * @param {I} action The action to run.\n   * @return {Promise<T>} A promise that resolves to the run result.\n   */\n  public abstract run(action: I): Promise<O>;\n\n  /**\n   * Run the given action on this actor\n   * AND invokes the {@link Bus#onRun} method.\n   *\n   * @param {I} action The action to run.\n   * @return {Promise<T>} A promise that resolves to the run result.\n   */\n  public runObservable(action: I): Promise<O> {\n    const output: Promise<O> = this.run(action);\n    this.bus.onRun(this, action, output);\n    return output;\n  }\n\n  /**\n   * Initialize this actor.\n   * This should be used for doing things that take a while,\n   * such as opening files.\n   *\n   * @return {Promise<void>} A promise that resolves when the actor has been initialized.\n   */\n  public async initialize(): Promise<any> {\n    return true;\n  }\n\n  /**\n   * Deinitialize this actor.\n   * This should be used for cleaning up things when the application is shut down,\n   * such as closing files and removing temporary files.\n   *\n   * @return {Promise<void>} A promise that resolves when the actor has been deinitialized.\n   */\n  public async deinitialize(): Promise<any> {\n    return true;\n  }\n\n  /* Proxy methods for the (optional) logger that is defined in the context */\n\n  protected getDefaultLogData(context: ActionContext | undefined, data?: (() => any)): any {\n    const dataActual = data ? data() : {};\n    dataActual.actor = this.name;\n    return dataActual;\n  }\n\n  protected logTrace(context: ActionContext | undefined, message: string, data?: (() => any)): void {\n    const logger: Logger | undefined = Actor.getContextLogger(context);\n    if (logger) {\n      logger.trace(message, this.getDefaultLogData(context, data));\n    }\n  }\n\n  protected logDebug(context: ActionContext | undefined, message: string, data?: (() => any)): void {\n    const logger: Logger | undefined = Actor.getContextLogger(context);\n    if (logger) {\n      logger.debug(message, this.getDefaultLogData(context, data));\n    }\n  }\n\n  protected logInfo(context: ActionContext | undefined, message: string, data?: (() => any)): void {\n    const logger: Logger | undefined = Actor.getContextLogger(context);\n    if (logger) {\n      logger.info(message, this.getDefaultLogData(context, data));\n    }\n  }\n\n  protected logWarn(context: ActionContext | undefined, message: string, data?: (() => any)): void {\n    const logger: Logger | undefined = Actor.getContextLogger(context);\n    if (logger) {\n      logger.warn(message, this.getDefaultLogData(context, data));\n    }\n  }\n\n  protected logError(context: ActionContext | undefined, message: string, data?: (() => any)): void {\n    const logger: Logger | undefined = Actor.getContextLogger(context);\n    if (logger) {\n      logger.error(message, this.getDefaultLogData(context, data));\n    }\n  }\n\n  protected logFatal(context: ActionContext | undefined, message: string, data?: (() => any)): void {\n    const logger: Logger | undefined = Actor.getContextLogger(context);\n    if (logger) {\n      logger.fatal(message, this.getDefaultLogData(context, data));\n    }\n  }\n}\n\nexport interface IActorArgs<I extends IAction, T extends IActorTest, O extends IActorOutput> {\n  name: string;\n  bus: Bus<Actor<I, T, O>, I, T, O>;\n  beforeActors?: Actor<I, T, O>[];\n}\n\n/**\n * An immutable key-value mapped context that can be passed to any (@link IAction}.\n * All actors that receive a context must forward this context to any actor, mediator or bus that it calls.\n * This context may be transformed before forwarding.\n *\n * Each bus should describe in its action interface which context entries are possible (non-restrictive)\n * and expose a `KEY_CONTEXT_${ENTRY_NAME}` constant for easy reuse.\n * If actors support any specific context entries next to those inherited by the bus action interface,\n * then this should be described in its README file.\n *\n * To avoid entry conflicts, all keys must be properly namespaced using the following convention:\n *   Each key must be prefixed with the package name followed by a `:`.\n *   For example, the `rdf-resolve-quad-pattern` bus declares the `sources` entry,\n *   which should be named as `@comunica/bus-rdf-resolve-quad-pattern:sources`.\n *\n * This context can contain any information that might be relevant for certain actors.\n * For instance, this context can contain a list of datasources over which operators should query.\n */\nexport type ActionContext = Map<string, any>;\n\n/**\n * A convenience constructor for {@link ActionContext} based on a given hash.\n * @param {{[p: string]: any}} hash A hash that maps keys to values.\n * @return {ActionContext} The immutable action context from the hash.\n * @constructor\n */\n// eslint-disable-next-line no-redeclare\nexport function ActionContext(hash: Record<string, any>): ActionContext {\n  return Map(hash);\n}\n\n/**\n * Convert the given object to an action context object if it is not an action context object yet.\n * If it already is an action context object, return the object as-is.\n * @param maybeActionContext Any object.\n * @return {ActionContext} An action context object.\n */\nexport function ensureActionContext(maybeActionContext: any): ActionContext {\n  return Map.isMap(maybeActionContext) ? maybeActionContext : ActionContext(maybeActionContext);\n}\n\n/**\n * Data interface for the type of action.\n */\nexport interface IAction {\n\n  /**\n   * The optional input context that is passed through by actors.\n   */\n  context?: ActionContext;\n}\n\n/**\n * Data interface for the type of an actor test result.\n */\nexport interface IActorTest {\n\n}\n\n/**\n * Data interface for the type of an actor run result.\n */\nexport interface IActorOutput {\n\n}\n"]}