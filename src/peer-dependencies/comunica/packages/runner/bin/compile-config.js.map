{"version":3,"file":"compile-config.js","sourceRoot":"","sources":["compile-config.ts"],"names":[],"mappings":";;AACA,6FAA6F;AAC7F,uCAAuC;AACvC,gGAAgG;;AAEhG,2BAAsC;AACtC,+BAA2B;AAE3B,+CAA6C;AAE7C,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAEnC,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;IACrB,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,0EAA0E,CAAC,CAAC;IACjG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;CACjB;AAED,MAAM,cAAc,GAAW,OAAO,CAAC,GAAG,EAAE,CAAC;AAC7C,MAAM,iBAAiB,GAAG,iBAAiB,CAAC;AAC5C,MAAM,UAAU,GAAW,IAAI,CAAC,CAAC,CAAC,CAAC;AACnC,MAAM,eAAe,GAAW,qBAAgB,CAAC,UAAU,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;AACnF,IAAI,kBAAkB,GAAG,yBAAyB,CAAC;AACnD,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;IACnB,kBAAkB,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;CAC9B;AAED,gGAAgG;AAChG,uFAAuF;AACvF,oCAAoC;AACpC,IAAI,OAAO,CAAC,IAAI,EAAE;IAChB,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;IACxB,MAAM,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,UAAG,CAAC,CAAC;IAC5C,KAAK,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QACzC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,UAAG,CAAC,GAAG,UAAG,cAAc,CAAC,CAAC;KACjF;CACF;AAED,4BAAa,CAAC,EAAE,cAAc,EAAE,EAAE,UAAU,EAAE,eAAe,EAAE,iBAAiB,EAAE,kBAAkB,CAAC;KAClG,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE;IAC3D,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC;IACzC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAClB,CAAC,CAAC,CAAC","sourcesContent":["#!/usr/bin/env node\n// Compiles a configuration to a module (single file) that exports the instantiated instance,\n// where all dependencies are injected.\n// This is a simplified version of components-compile-config that is shipped with Components.js.\n\nimport { createReadStream } from 'fs';\nimport { sep } from 'path';\nimport type { Stream } from 'stream';\nimport { compileConfig } from 'componentsjs';\n\nconst args = process.argv.slice(2);\n\nif (args.length === 0) {\n  process.stderr.write('Usage: comunica-compile-config path/to/config.json [urn:of:init:actor]\\n');\n  process.exit(1);\n}\n\nconst mainModulePath: string = process.cwd();\nconst configResourceUri = 'urn:comunica:my';\nconst configPath: string = args[0];\nconst configStreamRaw: Stream = createReadStream(configPath, { encoding: 'utf8' });\nlet exportVariableName = 'urn:comunica:sparqlinit';\nif (args.length > 1) {\n  exportVariableName = args[1];\n}\n\n// Hack our require path so that compilation in a monorepo dev environment always works properly\n// Otherwise, Components.js will think that we are running inside the 'runner' package,\n// and it will use its node_modules.\nif (require.main) {\n  require.main.paths = [];\n  const pathParts = mainModulePath.split(sep);\n  for (let i = pathParts.length; i > 0; i--) {\n    require.main.paths.push(`${pathParts.slice(0, i).join(sep) + sep}node_modules`);\n  }\n}\n\ncompileConfig({ mainModulePath }, configPath, configStreamRaw, configResourceUri, exportVariableName)\n  .then(out => process.stdout.write(`${out}\\n`)).catch(error => {\n    process.stderr.write(`${error.stack}\\n`);\n    process.exit(1);\n  });\n"]}